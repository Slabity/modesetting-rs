/* automatically generated by rust-bindgen */

#[repr(C)]
pub struct __BindgenUnionField<T>(::std::marker::PhantomData<T>);
impl <T> __BindgenUnionField<T> {
    #[inline]
    pub fn new() -> Self { __BindgenUnionField(::std::marker::PhantomData) }
    #[inline]
    pub unsafe fn as_ref(&self) -> &T { ::std::mem::transmute(self) }
    #[inline]
    pub unsafe fn as_mut(&mut self) -> &mut T { ::std::mem::transmute(self) }
}
impl <T> ::std::default::Default for __BindgenUnionField<T> {
    #[inline]
    fn default() -> Self { Self::new() }
}
impl <T> ::std::clone::Clone for __BindgenUnionField<T> {
    #[inline]
    fn clone(&self) -> Self { Self::new() }
}
impl <T> ::std::marker::Copy for __BindgenUnionField<T> { }
impl <T> ::std::fmt::Debug for __BindgenUnionField<T> {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        fmt.write_str("__BindgenUnionField")
    }
}
pub const __llvm__: libc::c_uint = 1;
pub const __clang__: libc::c_uint = 1;
pub const __clang_major__: libc::c_uint = 4;
pub const __clang_minor__: libc::c_uint = 0;
pub const __clang_patchlevel__: libc::c_uint = 0;
pub const __clang_version__: &'static [u8; 31usize] =
    b"4.0.0 (tags/RELEASE_400/final)\x00";
pub const __GNUC_MINOR__: libc::c_uint = 2;
pub const __GNUC_PATCHLEVEL__: libc::c_uint = 1;
pub const __GNUC__: libc::c_uint = 4;
pub const __GXX_ABI_VERSION: libc::c_uint = 1002;
pub const __ATOMIC_RELAXED: libc::c_uint = 0;
pub const __ATOMIC_CONSUME: libc::c_uint = 1;
pub const __ATOMIC_ACQUIRE: libc::c_uint = 2;
pub const __ATOMIC_RELEASE: libc::c_uint = 3;
pub const __ATOMIC_ACQ_REL: libc::c_uint = 4;
pub const __ATOMIC_SEQ_CST: libc::c_uint = 5;
pub const __PRAGMA_REDEFINE_EXTNAME: libc::c_uint = 1;
pub const __VERSION__: &'static [u8; 54usize] =
    b"4.2.1 Compatible Clang 4.0.0 (tags/RELEASE_400/final)\x00";
pub const __CONSTANT_CFSTRINGS__: libc::c_uint = 1;
pub const __ORDER_LITTLE_ENDIAN__: libc::c_uint = 1234;
pub const __ORDER_BIG_ENDIAN__: libc::c_uint = 4321;
pub const __ORDER_PDP_ENDIAN__: libc::c_uint = 3412;
pub const __BYTE_ORDER__: libc::c_uint = 1234;
pub const __LITTLE_ENDIAN__: libc::c_uint = 1;
pub const _LP64: libc::c_uint = 1;
pub const __LP64__: libc::c_uint = 1;
pub const __CHAR_BIT__: libc::c_uint = 8;
pub const __SCHAR_MAX__: libc::c_uint = 127;
pub const __SHRT_MAX__: libc::c_uint = 32767;
pub const __INT_MAX__: libc::c_uint = 2147483647;
pub const __LONG_MAX__: libc::c_ulonglong = 9223372036854775807;
pub const __LONG_LONG_MAX__: libc::c_ulonglong = 9223372036854775807;
pub const __WCHAR_MAX__: libc::c_uint = 2147483647;
pub const __INTMAX_MAX__: libc::c_ulonglong = 9223372036854775807;
pub const __SIZE_MAX__: libc::c_int = -1;
pub const __UINTMAX_MAX__: libc::c_int = -1;
pub const __PTRDIFF_MAX__: libc::c_ulonglong = 9223372036854775807;
pub const __INTPTR_MAX__: libc::c_ulonglong = 9223372036854775807;
pub const __UINTPTR_MAX__: libc::c_int = -1;
pub const __SIZEOF_DOUBLE__: libc::c_uint = 8;
pub const __SIZEOF_FLOAT__: libc::c_uint = 4;
pub const __SIZEOF_INT__: libc::c_uint = 4;
pub const __SIZEOF_LONG__: libc::c_uint = 8;
pub const __SIZEOF_LONG_DOUBLE__: libc::c_uint = 16;
pub const __SIZEOF_LONG_LONG__: libc::c_uint = 8;
pub const __SIZEOF_POINTER__: libc::c_uint = 8;
pub const __SIZEOF_SHORT__: libc::c_uint = 2;
pub const __SIZEOF_PTRDIFF_T__: libc::c_uint = 8;
pub const __SIZEOF_SIZE_T__: libc::c_uint = 8;
pub const __SIZEOF_WCHAR_T__: libc::c_uint = 4;
pub const __SIZEOF_WINT_T__: libc::c_uint = 4;
pub const __SIZEOF_INT128__: libc::c_uint = 16;
pub const __INTMAX_FMTd__: &'static [u8; 3usize] = b"ld\x00";
pub const __INTMAX_FMTi__: &'static [u8; 3usize] = b"li\x00";
pub const __UINTMAX_FMTo__: &'static [u8; 3usize] = b"lo\x00";
pub const __UINTMAX_FMTu__: &'static [u8; 3usize] = b"lu\x00";
pub const __UINTMAX_FMTx__: &'static [u8; 3usize] = b"lx\x00";
pub const __UINTMAX_FMTX__: &'static [u8; 3usize] = b"lX\x00";
pub const __INTMAX_WIDTH__: libc::c_uint = 64;
pub const __PTRDIFF_FMTd__: &'static [u8; 3usize] = b"ld\x00";
pub const __PTRDIFF_FMTi__: &'static [u8; 3usize] = b"li\x00";
pub const __PTRDIFF_WIDTH__: libc::c_uint = 64;
pub const __INTPTR_FMTd__: &'static [u8; 3usize] = b"ld\x00";
pub const __INTPTR_FMTi__: &'static [u8; 3usize] = b"li\x00";
pub const __INTPTR_WIDTH__: libc::c_uint = 64;
pub const __SIZE_FMTo__: &'static [u8; 3usize] = b"lo\x00";
pub const __SIZE_FMTu__: &'static [u8; 3usize] = b"lu\x00";
pub const __SIZE_FMTx__: &'static [u8; 3usize] = b"lx\x00";
pub const __SIZE_FMTX__: &'static [u8; 3usize] = b"lX\x00";
pub const __SIZE_WIDTH__: libc::c_uint = 64;
pub const __WCHAR_WIDTH__: libc::c_uint = 32;
pub const __WINT_WIDTH__: libc::c_uint = 32;
pub const __SIG_ATOMIC_WIDTH__: libc::c_uint = 32;
pub const __SIG_ATOMIC_MAX__: libc::c_uint = 2147483647;
pub const __UINTMAX_WIDTH__: libc::c_uint = 64;
pub const __UINTPTR_FMTo__: &'static [u8; 3usize] = b"lo\x00";
pub const __UINTPTR_FMTu__: &'static [u8; 3usize] = b"lu\x00";
pub const __UINTPTR_FMTx__: &'static [u8; 3usize] = b"lx\x00";
pub const __UINTPTR_FMTX__: &'static [u8; 3usize] = b"lX\x00";
pub const __UINTPTR_WIDTH__: libc::c_uint = 64;
pub const __FLT_HAS_DENORM__: libc::c_uint = 1;
pub const __FLT_DIG__: libc::c_uint = 6;
pub const __FLT_DECIMAL_DIG__: libc::c_uint = 9;
pub const __FLT_HAS_INFINITY__: libc::c_uint = 1;
pub const __FLT_HAS_QUIET_NAN__: libc::c_uint = 1;
pub const __FLT_MANT_DIG__: libc::c_uint = 24;
pub const __FLT_MAX_10_EXP__: libc::c_uint = 38;
pub const __FLT_MAX_EXP__: libc::c_uint = 128;
pub const __FLT_MIN_10_EXP__: libc::c_int = -37;
pub const __FLT_MIN_EXP__: libc::c_int = -125;
pub const __DBL_HAS_DENORM__: libc::c_uint = 1;
pub const __DBL_DIG__: libc::c_uint = 15;
pub const __DBL_DECIMAL_DIG__: libc::c_uint = 17;
pub const __DBL_HAS_INFINITY__: libc::c_uint = 1;
pub const __DBL_HAS_QUIET_NAN__: libc::c_uint = 1;
pub const __DBL_MANT_DIG__: libc::c_uint = 53;
pub const __DBL_MAX_10_EXP__: libc::c_uint = 308;
pub const __DBL_MAX_EXP__: libc::c_uint = 1024;
pub const __DBL_MIN_10_EXP__: libc::c_int = -307;
pub const __DBL_MIN_EXP__: libc::c_int = -1021;
pub const __LDBL_HAS_DENORM__: libc::c_uint = 1;
pub const __LDBL_DIG__: libc::c_uint = 18;
pub const __LDBL_DECIMAL_DIG__: libc::c_uint = 21;
pub const __LDBL_HAS_INFINITY__: libc::c_uint = 1;
pub const __LDBL_HAS_QUIET_NAN__: libc::c_uint = 1;
pub const __LDBL_MANT_DIG__: libc::c_uint = 64;
pub const __LDBL_MAX_10_EXP__: libc::c_uint = 4932;
pub const __LDBL_MAX_EXP__: libc::c_uint = 16384;
pub const __LDBL_MIN_10_EXP__: libc::c_int = -4931;
pub const __LDBL_MIN_EXP__: libc::c_int = -16381;
pub const __POINTER_WIDTH__: libc::c_uint = 64;
pub const __BIGGEST_ALIGNMENT__: libc::c_uint = 16;
pub const __WINT_UNSIGNED__: libc::c_uint = 1;
pub const __INT8_FMTd__: &'static [u8; 4usize] = b"hhd\x00";
pub const __INT8_FMTi__: &'static [u8; 4usize] = b"hhi\x00";
pub const __INT16_FMTd__: &'static [u8; 3usize] = b"hd\x00";
pub const __INT16_FMTi__: &'static [u8; 3usize] = b"hi\x00";
pub const __INT32_FMTd__: &'static [u8; 2usize] = b"d\x00";
pub const __INT32_FMTi__: &'static [u8; 2usize] = b"i\x00";
pub const __INT64_FMTd__: &'static [u8; 3usize] = b"ld\x00";
pub const __INT64_FMTi__: &'static [u8; 3usize] = b"li\x00";
pub const __UINT8_FMTo__: &'static [u8; 4usize] = b"hho\x00";
pub const __UINT8_FMTu__: &'static [u8; 4usize] = b"hhu\x00";
pub const __UINT8_FMTx__: &'static [u8; 4usize] = b"hhx\x00";
pub const __UINT8_FMTX__: &'static [u8; 4usize] = b"hhX\x00";
pub const __UINT8_MAX__: libc::c_uint = 255;
pub const __INT8_MAX__: libc::c_uint = 127;
pub const __UINT16_FMTo__: &'static [u8; 3usize] = b"ho\x00";
pub const __UINT16_FMTu__: &'static [u8; 3usize] = b"hu\x00";
pub const __UINT16_FMTx__: &'static [u8; 3usize] = b"hx\x00";
pub const __UINT16_FMTX__: &'static [u8; 3usize] = b"hX\x00";
pub const __UINT16_MAX__: libc::c_uint = 65535;
pub const __INT16_MAX__: libc::c_uint = 32767;
pub const __UINT32_FMTo__: &'static [u8; 2usize] = b"o\x00";
pub const __UINT32_FMTu__: &'static [u8; 2usize] = b"u\x00";
pub const __UINT32_FMTx__: &'static [u8; 2usize] = b"x\x00";
pub const __UINT32_FMTX__: &'static [u8; 2usize] = b"X\x00";
pub const __UINT32_MAX__: libc::c_uint = 4294967295;
pub const __INT32_MAX__: libc::c_uint = 2147483647;
pub const __UINT64_FMTo__: &'static [u8; 3usize] = b"lo\x00";
pub const __UINT64_FMTu__: &'static [u8; 3usize] = b"lu\x00";
pub const __UINT64_FMTx__: &'static [u8; 3usize] = b"lx\x00";
pub const __UINT64_FMTX__: &'static [u8; 3usize] = b"lX\x00";
pub const __UINT64_MAX__: libc::c_int = -1;
pub const __INT64_MAX__: libc::c_ulonglong = 9223372036854775807;
pub const __INT_LEAST8_MAX__: libc::c_uint = 127;
pub const __INT_LEAST8_FMTd__: &'static [u8; 4usize] = b"hhd\x00";
pub const __INT_LEAST8_FMTi__: &'static [u8; 4usize] = b"hhi\x00";
pub const __UINT_LEAST8_MAX__: libc::c_uint = 255;
pub const __UINT_LEAST8_FMTo__: &'static [u8; 4usize] = b"hho\x00";
pub const __UINT_LEAST8_FMTu__: &'static [u8; 4usize] = b"hhu\x00";
pub const __UINT_LEAST8_FMTx__: &'static [u8; 4usize] = b"hhx\x00";
pub const __UINT_LEAST8_FMTX__: &'static [u8; 4usize] = b"hhX\x00";
pub const __INT_LEAST16_MAX__: libc::c_uint = 32767;
pub const __INT_LEAST16_FMTd__: &'static [u8; 3usize] = b"hd\x00";
pub const __INT_LEAST16_FMTi__: &'static [u8; 3usize] = b"hi\x00";
pub const __UINT_LEAST16_MAX__: libc::c_uint = 65535;
pub const __UINT_LEAST16_FMTo__: &'static [u8; 3usize] = b"ho\x00";
pub const __UINT_LEAST16_FMTu__: &'static [u8; 3usize] = b"hu\x00";
pub const __UINT_LEAST16_FMTx__: &'static [u8; 3usize] = b"hx\x00";
pub const __UINT_LEAST16_FMTX__: &'static [u8; 3usize] = b"hX\x00";
pub const __INT_LEAST32_MAX__: libc::c_uint = 2147483647;
pub const __INT_LEAST32_FMTd__: &'static [u8; 2usize] = b"d\x00";
pub const __INT_LEAST32_FMTi__: &'static [u8; 2usize] = b"i\x00";
pub const __UINT_LEAST32_MAX__: libc::c_uint = 4294967295;
pub const __UINT_LEAST32_FMTo__: &'static [u8; 2usize] = b"o\x00";
pub const __UINT_LEAST32_FMTu__: &'static [u8; 2usize] = b"u\x00";
pub const __UINT_LEAST32_FMTx__: &'static [u8; 2usize] = b"x\x00";
pub const __UINT_LEAST32_FMTX__: &'static [u8; 2usize] = b"X\x00";
pub const __INT_LEAST64_MAX__: libc::c_ulonglong = 9223372036854775807;
pub const __INT_LEAST64_FMTd__: &'static [u8; 3usize] = b"ld\x00";
pub const __INT_LEAST64_FMTi__: &'static [u8; 3usize] = b"li\x00";
pub const __UINT_LEAST64_MAX__: libc::c_int = -1;
pub const __UINT_LEAST64_FMTo__: &'static [u8; 3usize] = b"lo\x00";
pub const __UINT_LEAST64_FMTu__: &'static [u8; 3usize] = b"lu\x00";
pub const __UINT_LEAST64_FMTx__: &'static [u8; 3usize] = b"lx\x00";
pub const __UINT_LEAST64_FMTX__: &'static [u8; 3usize] = b"lX\x00";
pub const __INT_FAST8_MAX__: libc::c_uint = 127;
pub const __INT_FAST8_FMTd__: &'static [u8; 4usize] = b"hhd\x00";
pub const __INT_FAST8_FMTi__: &'static [u8; 4usize] = b"hhi\x00";
pub const __UINT_FAST8_MAX__: libc::c_uint = 255;
pub const __UINT_FAST8_FMTo__: &'static [u8; 4usize] = b"hho\x00";
pub const __UINT_FAST8_FMTu__: &'static [u8; 4usize] = b"hhu\x00";
pub const __UINT_FAST8_FMTx__: &'static [u8; 4usize] = b"hhx\x00";
pub const __UINT_FAST8_FMTX__: &'static [u8; 4usize] = b"hhX\x00";
pub const __INT_FAST16_MAX__: libc::c_uint = 32767;
pub const __INT_FAST16_FMTd__: &'static [u8; 3usize] = b"hd\x00";
pub const __INT_FAST16_FMTi__: &'static [u8; 3usize] = b"hi\x00";
pub const __UINT_FAST16_MAX__: libc::c_uint = 65535;
pub const __UINT_FAST16_FMTo__: &'static [u8; 3usize] = b"ho\x00";
pub const __UINT_FAST16_FMTu__: &'static [u8; 3usize] = b"hu\x00";
pub const __UINT_FAST16_FMTx__: &'static [u8; 3usize] = b"hx\x00";
pub const __UINT_FAST16_FMTX__: &'static [u8; 3usize] = b"hX\x00";
pub const __INT_FAST32_MAX__: libc::c_uint = 2147483647;
pub const __INT_FAST32_FMTd__: &'static [u8; 2usize] = b"d\x00";
pub const __INT_FAST32_FMTi__: &'static [u8; 2usize] = b"i\x00";
pub const __UINT_FAST32_MAX__: libc::c_uint = 4294967295;
pub const __UINT_FAST32_FMTo__: &'static [u8; 2usize] = b"o\x00";
pub const __UINT_FAST32_FMTu__: &'static [u8; 2usize] = b"u\x00";
pub const __UINT_FAST32_FMTx__: &'static [u8; 2usize] = b"x\x00";
pub const __UINT_FAST32_FMTX__: &'static [u8; 2usize] = b"X\x00";
pub const __INT_FAST64_MAX__: libc::c_ulonglong = 9223372036854775807;
pub const __INT_FAST64_FMTd__: &'static [u8; 3usize] = b"ld\x00";
pub const __INT_FAST64_FMTi__: &'static [u8; 3usize] = b"li\x00";
pub const __UINT_FAST64_MAX__: libc::c_int = -1;
pub const __UINT_FAST64_FMTo__: &'static [u8; 3usize] = b"lo\x00";
pub const __UINT_FAST64_FMTu__: &'static [u8; 3usize] = b"lu\x00";
pub const __UINT_FAST64_FMTx__: &'static [u8; 3usize] = b"lx\x00";
pub const __UINT_FAST64_FMTX__: &'static [u8; 3usize] = b"lX\x00";
pub const __FINITE_MATH_ONLY__: libc::c_uint = 0;
pub const __GNUC_STDC_INLINE__: libc::c_uint = 1;
pub const __GCC_ATOMIC_TEST_AND_SET_TRUEVAL: libc::c_uint = 1;
pub const __GCC_ATOMIC_BOOL_LOCK_FREE: libc::c_uint = 2;
pub const __GCC_ATOMIC_CHAR_LOCK_FREE: libc::c_uint = 2;
pub const __GCC_ATOMIC_CHAR16_T_LOCK_FREE: libc::c_uint = 2;
pub const __GCC_ATOMIC_CHAR32_T_LOCK_FREE: libc::c_uint = 2;
pub const __GCC_ATOMIC_WCHAR_T_LOCK_FREE: libc::c_uint = 2;
pub const __GCC_ATOMIC_SHORT_LOCK_FREE: libc::c_uint = 2;
pub const __GCC_ATOMIC_INT_LOCK_FREE: libc::c_uint = 2;
pub const __GCC_ATOMIC_LONG_LOCK_FREE: libc::c_uint = 2;
pub const __GCC_ATOMIC_LLONG_LOCK_FREE: libc::c_uint = 2;
pub const __GCC_ATOMIC_POINTER_LOCK_FREE: libc::c_uint = 2;
pub const __NO_INLINE__: libc::c_uint = 1;
pub const __FLT_EVAL_METHOD__: libc::c_uint = 0;
pub const __FLT_RADIX__: libc::c_uint = 2;
pub const __DECIMAL_DIG__: libc::c_uint = 21;
pub const __amd64__: libc::c_uint = 1;
pub const __amd64: libc::c_uint = 1;
pub const __x86_64: libc::c_uint = 1;
pub const __x86_64__: libc::c_uint = 1;
pub const __k8: libc::c_uint = 1;
pub const __k8__: libc::c_uint = 1;
pub const __tune_k8__: libc::c_uint = 1;
pub const __NO_MATH_INLINES: libc::c_uint = 1;
pub const __FXSR__: libc::c_uint = 1;
pub const __SSE2__: libc::c_uint = 1;
pub const __SSE2_MATH__: libc::c_uint = 1;
pub const __SSE__: libc::c_uint = 1;
pub const __SSE_MATH__: libc::c_uint = 1;
pub const __MMX__: libc::c_uint = 1;
pub const __GCC_HAVE_SYNC_COMPARE_AND_SWAP_1: libc::c_uint = 1;
pub const __GCC_HAVE_SYNC_COMPARE_AND_SWAP_2: libc::c_uint = 1;
pub const __GCC_HAVE_SYNC_COMPARE_AND_SWAP_4: libc::c_uint = 1;
pub const __GCC_HAVE_SYNC_COMPARE_AND_SWAP_8: libc::c_uint = 1;
pub const unix: libc::c_uint = 1;
pub const __unix: libc::c_uint = 1;
pub const __unix__: libc::c_uint = 1;
pub const linux: libc::c_uint = 1;
pub const __linux: libc::c_uint = 1;
pub const __linux__: libc::c_uint = 1;
pub const __gnu_linux__: libc::c_uint = 1;
pub const __ELF__: libc::c_uint = 1;
pub const __FLOAT128__: libc::c_uint = 1;
pub const __STDC__: libc::c_uint = 1;
pub const __STDC_HOSTED__: libc::c_uint = 1;
pub const __STDC_VERSION__: libc::c_uint = 201112;
pub const __STDC_UTF_16__: libc::c_uint = 1;
pub const __STDC_UTF_32__: libc::c_uint = 1;
pub const _STDINT_H: libc::c_uint = 1;
pub const _FEATURES_H: libc::c_uint = 1;
pub const _DEFAULT_SOURCE: libc::c_uint = 1;
pub const __USE_ISOC11: libc::c_uint = 1;
pub const __USE_ISOC99: libc::c_uint = 1;
pub const __USE_ISOC95: libc::c_uint = 1;
pub const __USE_POSIX_IMPLICITLY: libc::c_uint = 1;
pub const _POSIX_SOURCE: libc::c_uint = 1;
pub const _POSIX_C_SOURCE: libc::c_uint = 200809;
pub const __USE_POSIX: libc::c_uint = 1;
pub const __USE_POSIX2: libc::c_uint = 1;
pub const __USE_POSIX199309: libc::c_uint = 1;
pub const __USE_POSIX199506: libc::c_uint = 1;
pub const __USE_XOPEN2K: libc::c_uint = 1;
pub const __USE_XOPEN2K8: libc::c_uint = 1;
pub const _ATFILE_SOURCE: libc::c_uint = 1;
pub const __USE_MISC: libc::c_uint = 1;
pub const __USE_ATFILE: libc::c_uint = 1;
pub const __USE_FORTIFY_LEVEL: libc::c_uint = 0;
pub const _STDC_PREDEF_H: libc::c_uint = 1;
pub const __STDC_IEC_559__: libc::c_uint = 1;
pub const __STDC_IEC_559_COMPLEX__: libc::c_uint = 1;
pub const __STDC_ISO_10646__: libc::c_uint = 201505;
pub const __STDC_NO_THREADS__: libc::c_uint = 1;
pub const __GNU_LIBRARY__: libc::c_uint = 6;
pub const __GLIBC__: libc::c_uint = 2;
pub const __GLIBC_MINOR__: libc::c_uint = 24;
pub const _SYS_CDEFS_H: libc::c_uint = 1;
pub const __WORDSIZE: libc::c_uint = 64;
pub const __WORDSIZE_TIME64_COMPAT32: libc::c_uint = 1;
pub const __SYSCALL_WORDSIZE: libc::c_uint = 64;
pub const _BITS_WCHAR_H: libc::c_uint = 1;
pub const __WCHAR_MAX: libc::c_uint = 2147483647;
pub const __WCHAR_MIN: libc::c_int = -2147483648;
pub const INT8_MIN: libc::c_int = -128;
pub const INT16_MIN: libc::c_int = -32768;
pub const INT32_MIN: libc::c_int = -2147483648;
pub const INT8_MAX: libc::c_uint = 127;
pub const INT16_MAX: libc::c_uint = 32767;
pub const INT32_MAX: libc::c_uint = 2147483647;
pub const UINT8_MAX: libc::c_uint = 255;
pub const UINT16_MAX: libc::c_uint = 65535;
pub const UINT32_MAX: libc::c_uint = 4294967295;
pub const INT_LEAST8_MIN: libc::c_int = -128;
pub const INT_LEAST16_MIN: libc::c_int = -32768;
pub const INT_LEAST32_MIN: libc::c_int = -2147483648;
pub const INT_LEAST8_MAX: libc::c_uint = 127;
pub const INT_LEAST16_MAX: libc::c_uint = 32767;
pub const INT_LEAST32_MAX: libc::c_uint = 2147483647;
pub const UINT_LEAST8_MAX: libc::c_uint = 255;
pub const UINT_LEAST16_MAX: libc::c_uint = 65535;
pub const UINT_LEAST32_MAX: libc::c_uint = 4294967295;
pub const INT_FAST8_MIN: libc::c_int = -128;
pub const INT_FAST16_MIN: libc::c_longlong = -9223372036854775808;
pub const INT_FAST32_MIN: libc::c_longlong = -9223372036854775808;
pub const INT_FAST8_MAX: libc::c_uint = 127;
pub const INT_FAST16_MAX: libc::c_ulonglong = 9223372036854775807;
pub const INT_FAST32_MAX: libc::c_ulonglong = 9223372036854775807;
pub const UINT_FAST8_MAX: libc::c_uint = 255;
pub const UINT_FAST16_MAX: libc::c_int = -1;
pub const UINT_FAST32_MAX: libc::c_int = -1;
pub const INTPTR_MIN: libc::c_longlong = -9223372036854775808;
pub const INTPTR_MAX: libc::c_ulonglong = 9223372036854775807;
pub const UINTPTR_MAX: libc::c_int = -1;
pub const PTRDIFF_MIN: libc::c_longlong = -9223372036854775808;
pub const PTRDIFF_MAX: libc::c_ulonglong = 9223372036854775807;
pub const SIG_ATOMIC_MIN: libc::c_int = -2147483648;
pub const SIG_ATOMIC_MAX: libc::c_uint = 2147483647;
pub const SIZE_MAX: libc::c_int = -1;
pub const WCHAR_MIN: libc::c_int = -2147483648;
pub const WCHAR_MAX: libc::c_uint = 2147483647;
pub const WINT_MIN: libc::c_uint = 0;
pub const WINT_MAX: libc::c_uint = 4294967295;
pub const __BITS_PER_LONG: libc::c_uint = 64;
pub const __FD_SETSIZE: libc::c_uint = 1024;
pub const _IOC_NRBITS: libc::c_uint = 8;
pub const _IOC_TYPEBITS: libc::c_uint = 8;
pub const _IOC_SIZEBITS: libc::c_uint = 14;
pub const _IOC_DIRBITS: libc::c_uint = 2;
pub const _IOC_NRMASK: libc::c_uint = 255;
pub const _IOC_TYPEMASK: libc::c_uint = 255;
pub const _IOC_SIZEMASK: libc::c_uint = 16383;
pub const _IOC_DIRMASK: libc::c_uint = 3;
pub const _IOC_NRSHIFT: libc::c_uint = 0;
pub const _IOC_TYPESHIFT: libc::c_uint = 8;
pub const _IOC_SIZESHIFT: libc::c_uint = 16;
pub const _IOC_DIRSHIFT: libc::c_uint = 30;
pub const _IOC_NONE: libc::c_uint = 0;
pub const _IOC_WRITE: libc::c_uint = 1;
pub const _IOC_READ: libc::c_uint = 2;
pub const IOC_IN: libc::c_uint = 1073741824;
pub const IOC_OUT: libc::c_uint = 2147483648;
pub const IOC_INOUT: libc::c_uint = 3221225472;
pub const IOCSIZE_MASK: libc::c_uint = 1073676288;
pub const IOCSIZE_SHIFT: libc::c_uint = 16;
pub const DRM_NAME: &'static [u8; 4usize] = b"drm\x00";
pub const DRM_MIN_ORDER: libc::c_uint = 5;
pub const DRM_MAX_ORDER: libc::c_uint = 22;
pub const DRM_RAM_PERCENT: libc::c_uint = 10;
pub const _DRM_LOCK_HELD: libc::c_uint = 2147483648;
pub const _DRM_LOCK_CONT: libc::c_uint = 1073741824;
pub const _DRM_VBLANK_HIGH_CRTC_SHIFT: libc::c_uint = 1;
pub const _DRM_PRE_MODESET: libc::c_uint = 1;
pub const _DRM_POST_MODESET: libc::c_uint = 2;
pub const DRM_CAP_DUMB_BUFFER: libc::c_uint = 1;
pub const DRM_CAP_VBLANK_HIGH_CRTC: libc::c_uint = 2;
pub const DRM_CAP_DUMB_PREFERRED_DEPTH: libc::c_uint = 3;
pub const DRM_CAP_DUMB_PREFER_SHADOW: libc::c_uint = 4;
pub const DRM_CAP_PRIME: libc::c_uint = 5;
pub const DRM_PRIME_CAP_IMPORT: libc::c_uint = 1;
pub const DRM_PRIME_CAP_EXPORT: libc::c_uint = 2;
pub const DRM_CAP_TIMESTAMP_MONOTONIC: libc::c_uint = 6;
pub const DRM_CAP_ASYNC_PAGE_FLIP: libc::c_uint = 7;
pub const DRM_CAP_CURSOR_WIDTH: libc::c_uint = 8;
pub const DRM_CAP_CURSOR_HEIGHT: libc::c_uint = 9;
pub const DRM_CAP_ADDFB2_MODIFIERS: libc::c_uint = 16;
pub const DRM_CAP_PAGE_FLIP_TARGET: libc::c_uint = 17;
pub const DRM_CLIENT_CAP_STEREO_3D: libc::c_uint = 1;
pub const DRM_CLIENT_CAP_UNIVERSAL_PLANES: libc::c_uint = 2;
pub const DRM_CLIENT_CAP_ATOMIC: libc::c_uint = 3;
pub const DRM_DISPLAY_INFO_LEN: libc::c_uint = 32;
pub const DRM_CONNECTOR_NAME_LEN: libc::c_uint = 32;
pub const DRM_DISPLAY_MODE_LEN: libc::c_uint = 32;
pub const DRM_PROP_NAME_LEN: libc::c_uint = 32;
pub const DRM_MODE_TYPE_BUILTIN: libc::c_uint = 1;
pub const DRM_MODE_TYPE_CLOCK_C: libc::c_uint = 3;
pub const DRM_MODE_TYPE_CRTC_C: libc::c_uint = 5;
pub const DRM_MODE_TYPE_PREFERRED: libc::c_uint = 8;
pub const DRM_MODE_TYPE_DEFAULT: libc::c_uint = 16;
pub const DRM_MODE_TYPE_USERDEF: libc::c_uint = 32;
pub const DRM_MODE_TYPE_DRIVER: libc::c_uint = 64;
pub const DRM_MODE_FLAG_PHSYNC: libc::c_uint = 1;
pub const DRM_MODE_FLAG_NHSYNC: libc::c_uint = 2;
pub const DRM_MODE_FLAG_PVSYNC: libc::c_uint = 4;
pub const DRM_MODE_FLAG_NVSYNC: libc::c_uint = 8;
pub const DRM_MODE_FLAG_INTERLACE: libc::c_uint = 16;
pub const DRM_MODE_FLAG_DBLSCAN: libc::c_uint = 32;
pub const DRM_MODE_FLAG_CSYNC: libc::c_uint = 64;
pub const DRM_MODE_FLAG_PCSYNC: libc::c_uint = 128;
pub const DRM_MODE_FLAG_NCSYNC: libc::c_uint = 256;
pub const DRM_MODE_FLAG_HSKEW: libc::c_uint = 512;
pub const DRM_MODE_FLAG_BCAST: libc::c_uint = 1024;
pub const DRM_MODE_FLAG_PIXMUX: libc::c_uint = 2048;
pub const DRM_MODE_FLAG_DBLCLK: libc::c_uint = 4096;
pub const DRM_MODE_FLAG_CLKDIV2: libc::c_uint = 8192;
pub const DRM_MODE_FLAG_3D_MASK: libc::c_uint = 507904;
pub const DRM_MODE_FLAG_3D_NONE: libc::c_uint = 0;
pub const DRM_MODE_FLAG_3D_FRAME_PACKING: libc::c_uint = 16384;
pub const DRM_MODE_FLAG_3D_FIELD_ALTERNATIVE: libc::c_uint = 32768;
pub const DRM_MODE_FLAG_3D_LINE_ALTERNATIVE: libc::c_uint = 49152;
pub const DRM_MODE_FLAG_3D_SIDE_BY_SIDE_FULL: libc::c_uint = 65536;
pub const DRM_MODE_FLAG_3D_L_DEPTH: libc::c_uint = 81920;
pub const DRM_MODE_FLAG_3D_L_DEPTH_GFX_GFX_DEPTH: libc::c_uint = 98304;
pub const DRM_MODE_FLAG_3D_TOP_AND_BOTTOM: libc::c_uint = 114688;
pub const DRM_MODE_FLAG_3D_SIDE_BY_SIDE_HALF: libc::c_uint = 131072;
pub const DRM_MODE_PICTURE_ASPECT_NONE: libc::c_uint = 0;
pub const DRM_MODE_PICTURE_ASPECT_4_3: libc::c_uint = 1;
pub const DRM_MODE_PICTURE_ASPECT_16_9: libc::c_uint = 2;
pub const DRM_MODE_FLAG_PIC_AR_MASK: libc::c_uint = 7864320;
pub const DRM_MODE_FLAG_PIC_AR_NONE: libc::c_uint = 0;
pub const DRM_MODE_FLAG_PIC_AR_4_3: libc::c_uint = 524288;
pub const DRM_MODE_FLAG_PIC_AR_16_9: libc::c_uint = 1048576;
pub const DRM_MODE_DPMS_ON: libc::c_uint = 0;
pub const DRM_MODE_DPMS_STANDBY: libc::c_uint = 1;
pub const DRM_MODE_DPMS_SUSPEND: libc::c_uint = 2;
pub const DRM_MODE_DPMS_OFF: libc::c_uint = 3;
pub const DRM_MODE_SCALE_NONE: libc::c_uint = 0;
pub const DRM_MODE_SCALE_FULLSCREEN: libc::c_uint = 1;
pub const DRM_MODE_SCALE_CENTER: libc::c_uint = 2;
pub const DRM_MODE_SCALE_ASPECT: libc::c_uint = 3;
pub const DRM_MODE_DITHERING_OFF: libc::c_uint = 0;
pub const DRM_MODE_DITHERING_ON: libc::c_uint = 1;
pub const DRM_MODE_DITHERING_AUTO: libc::c_uint = 2;
pub const DRM_MODE_DIRTY_OFF: libc::c_uint = 0;
pub const DRM_MODE_DIRTY_ON: libc::c_uint = 1;
pub const DRM_MODE_DIRTY_ANNOTATE: libc::c_uint = 2;
pub const DRM_MODE_PRESENT_TOP_FIELD: libc::c_uint = 1;
pub const DRM_MODE_PRESENT_BOTTOM_FIELD: libc::c_uint = 2;
pub const DRM_MODE_ENCODER_NONE: libc::c_uint = 0;
pub const DRM_MODE_ENCODER_DAC: libc::c_uint = 1;
pub const DRM_MODE_ENCODER_TMDS: libc::c_uint = 2;
pub const DRM_MODE_ENCODER_LVDS: libc::c_uint = 3;
pub const DRM_MODE_ENCODER_TVDAC: libc::c_uint = 4;
pub const DRM_MODE_ENCODER_VIRTUAL: libc::c_uint = 5;
pub const DRM_MODE_ENCODER_DSI: libc::c_uint = 6;
pub const DRM_MODE_ENCODER_DPMST: libc::c_uint = 7;
pub const DRM_MODE_ENCODER_DPI: libc::c_uint = 8;
pub const DRM_MODE_CONNECTOR_Unknown: libc::c_uint = 0;
pub const DRM_MODE_CONNECTOR_VGA: libc::c_uint = 1;
pub const DRM_MODE_CONNECTOR_DVII: libc::c_uint = 2;
pub const DRM_MODE_CONNECTOR_DVID: libc::c_uint = 3;
pub const DRM_MODE_CONNECTOR_DVIA: libc::c_uint = 4;
pub const DRM_MODE_CONNECTOR_Composite: libc::c_uint = 5;
pub const DRM_MODE_CONNECTOR_SVIDEO: libc::c_uint = 6;
pub const DRM_MODE_CONNECTOR_LVDS: libc::c_uint = 7;
pub const DRM_MODE_CONNECTOR_Component: libc::c_uint = 8;
pub const DRM_MODE_CONNECTOR_9PinDIN: libc::c_uint = 9;
pub const DRM_MODE_CONNECTOR_DisplayPort: libc::c_uint = 10;
pub const DRM_MODE_CONNECTOR_HDMIA: libc::c_uint = 11;
pub const DRM_MODE_CONNECTOR_HDMIB: libc::c_uint = 12;
pub const DRM_MODE_CONNECTOR_TV: libc::c_uint = 13;
pub const DRM_MODE_CONNECTOR_eDP: libc::c_uint = 14;
pub const DRM_MODE_CONNECTOR_VIRTUAL: libc::c_uint = 15;
pub const DRM_MODE_CONNECTOR_DSI: libc::c_uint = 16;
pub const DRM_MODE_CONNECTOR_DPI: libc::c_uint = 17;
pub const DRM_MODE_PROP_PENDING: libc::c_uint = 1;
pub const DRM_MODE_PROP_RANGE: libc::c_uint = 2;
pub const DRM_MODE_PROP_IMMUTABLE: libc::c_uint = 4;
pub const DRM_MODE_PROP_ENUM: libc::c_uint = 8;
pub const DRM_MODE_PROP_BLOB: libc::c_uint = 16;
pub const DRM_MODE_PROP_BITMASK: libc::c_uint = 32;
pub const DRM_MODE_PROP_LEGACY_TYPE: libc::c_uint = 58;
pub const DRM_MODE_PROP_EXTENDED_TYPE: libc::c_uint = 65472;
pub const DRM_MODE_PROP_ATOMIC: libc::c_uint = 2147483648;
pub const DRM_MODE_OBJECT_CRTC: libc::c_uint = 3435973836;
pub const DRM_MODE_OBJECT_CONNECTOR: libc::c_uint = 3233857728;
pub const DRM_MODE_OBJECT_ENCODER: libc::c_uint = 3772834016;
pub const DRM_MODE_OBJECT_MODE: libc::c_uint = 3739147998;
pub const DRM_MODE_OBJECT_PROPERTY: libc::c_uint = 2964369584;
pub const DRM_MODE_OBJECT_FB: libc::c_uint = 4227595259;
pub const DRM_MODE_OBJECT_BLOB: libc::c_uint = 3149642683;
pub const DRM_MODE_OBJECT_PLANE: libc::c_uint = 4008636142;
pub const DRM_MODE_OBJECT_ANY: libc::c_uint = 0;
pub const DRM_MODE_FB_INTERLACED: libc::c_uint = 1;
pub const DRM_MODE_FB_MODIFIERS: libc::c_uint = 2;
pub const DRM_MODE_FB_DIRTY_ANNOTATE_COPY: libc::c_uint = 1;
pub const DRM_MODE_FB_DIRTY_ANNOTATE_FILL: libc::c_uint = 2;
pub const DRM_MODE_FB_DIRTY_FLAGS: libc::c_uint = 3;
pub const DRM_MODE_FB_DIRTY_MAX_CLIPS: libc::c_uint = 256;
pub const DRM_MODE_CURSOR_BO: libc::c_uint = 1;
pub const DRM_MODE_CURSOR_MOVE: libc::c_uint = 2;
pub const DRM_MODE_CURSOR_FLAGS: libc::c_uint = 3;
pub const DRM_MODE_PAGE_FLIP_EVENT: libc::c_uint = 1;
pub const DRM_MODE_PAGE_FLIP_ASYNC: libc::c_uint = 2;
pub const DRM_MODE_PAGE_FLIP_TARGET_ABSOLUTE: libc::c_uint = 4;
pub const DRM_MODE_PAGE_FLIP_TARGET_RELATIVE: libc::c_uint = 8;
pub const DRM_MODE_PAGE_FLIP_TARGET: libc::c_uint = 12;
pub const DRM_MODE_PAGE_FLIP_FLAGS: libc::c_uint = 15;
pub const DRM_MODE_ATOMIC_TEST_ONLY: libc::c_uint = 256;
pub const DRM_MODE_ATOMIC_NONBLOCK: libc::c_uint = 512;
pub const DRM_MODE_ATOMIC_ALLOW_MODESET: libc::c_uint = 1024;
pub const DRM_MODE_ATOMIC_FLAGS: libc::c_uint = 1795;
pub const DRM_IOCTL_BASE: u8 = b'd';
pub const DRM_COMMAND_BASE: libc::c_uint = 64;
pub const DRM_COMMAND_END: libc::c_uint = 160;
pub const DRM_EVENT_VBLANK: libc::c_uint = 1;
pub const DRM_EVENT_FLIP_COMPLETE: libc::c_uint = 2;
pub const DRM_MODE_FEATURE_KMS: libc::c_uint = 1;
pub const DRM_MODE_FEATURE_DIRTYFB: libc::c_uint = 1;
pub const DRM_PLANE_TYPE_OVERLAY: libc::c_uint = 0;
pub const DRM_PLANE_TYPE_PRIMARY: libc::c_uint = 1;
pub const DRM_PLANE_TYPE_CURSOR: libc::c_uint = 2;
pub type int_least8_t = libc::c_char;
pub type int_least16_t = libc::c_short;
pub type int_least32_t = libc::c_int;
pub type int_least64_t = libc::c_long;
pub type uint_least8_t = libc::c_uchar;
pub type uint_least16_t = libc::c_ushort;
pub type uint_least32_t = libc::c_uint;
pub type uint_least64_t = libc::c_ulong;
pub type int_fast8_t = libc::c_char;
pub type int_fast16_t = libc::c_long;
pub type int_fast32_t = libc::c_long;
pub type int_fast64_t = libc::c_long;
pub type uint_fast8_t = libc::c_uchar;
pub type uint_fast16_t = libc::c_ulong;
pub type uint_fast32_t = libc::c_ulong;
pub type uint_fast64_t = libc::c_ulong;
pub type intmax_t = libc::c_long;
pub type uintmax_t = libc::c_ulong;
pub type wchar_t = libc::c_int;
pub type __s8 = libc::c_char;
pub type __u8 = libc::c_uchar;
pub type __s16 = libc::c_short;
pub type __u16 = libc::c_ushort;
pub type __s32 = libc::c_int;
pub type __u32 = libc::c_uint;
pub type __s64 = libc::c_longlong;
pub type __u64 = libc::c_ulonglong;
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct __kernel_fd_set {
    pub fds_bits: [libc::c_ulong; 16usize],
}
#[test]
fn bindgen_test_layout___kernel_fd_set() {
    assert_eq!(::std::mem::size_of::<__kernel_fd_set>() , 128usize , concat !
               ( "Size of: " , stringify ! ( __kernel_fd_set ) ));
    assert_eq! (::std::mem::align_of::<__kernel_fd_set>() , 8usize , concat !
                ( "Alignment of " , stringify ! ( __kernel_fd_set ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __kernel_fd_set ) ) . fds_bits as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( __kernel_fd_set ) ,
                "::" , stringify ! ( fds_bits ) ));
}
impl Clone for __kernel_fd_set {
    fn clone(&self) -> Self { *self }
}
pub type __kernel_sighandler_t =
    ::std::option::Option<unsafe extern "C" fn(arg1: libc::c_int)>;
pub type __kernel_key_t = libc::c_int;
pub type __kernel_mqd_t = libc::c_int;
pub type __kernel_old_uid_t = libc::c_ushort;
pub type __kernel_old_gid_t = libc::c_ushort;
pub type __kernel_old_dev_t = libc::c_ulong;
pub type __kernel_long_t = libc::c_long;
pub type __kernel_ulong_t = libc::c_ulong;
pub type __kernel_ino_t = __kernel_ulong_t;
pub type __kernel_mode_t = libc::c_uint;
pub type __kernel_pid_t = libc::c_int;
pub type __kernel_ipc_pid_t = libc::c_int;
pub type __kernel_uid_t = libc::c_uint;
pub type __kernel_gid_t = libc::c_uint;
pub type __kernel_suseconds_t = __kernel_long_t;
pub type __kernel_daddr_t = libc::c_int;
pub type __kernel_uid32_t = libc::c_uint;
pub type __kernel_gid32_t = libc::c_uint;
pub type __kernel_size_t = __kernel_ulong_t;
pub type __kernel_ssize_t = __kernel_long_t;
pub type __kernel_ptrdiff_t = __kernel_long_t;
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct __kernel_fsid_t {
    pub val: [libc::c_int; 2usize],
}
#[test]
fn bindgen_test_layout___kernel_fsid_t() {
    assert_eq!(::std::mem::size_of::<__kernel_fsid_t>() , 8usize , concat ! (
               "Size of: " , stringify ! ( __kernel_fsid_t ) ));
    assert_eq! (::std::mem::align_of::<__kernel_fsid_t>() , 4usize , concat !
                ( "Alignment of " , stringify ! ( __kernel_fsid_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __kernel_fsid_t ) ) . val as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( __kernel_fsid_t ) ,
                "::" , stringify ! ( val ) ));
}
impl Clone for __kernel_fsid_t {
    fn clone(&self) -> Self { *self }
}
pub type __kernel_off_t = __kernel_long_t;
pub type __kernel_loff_t = libc::c_longlong;
pub type __kernel_time_t = __kernel_long_t;
pub type __kernel_clock_t = __kernel_long_t;
pub type __kernel_timer_t = libc::c_int;
pub type __kernel_clockid_t = libc::c_int;
pub type __kernel_caddr_t = *mut libc::c_char;
pub type __kernel_uid16_t = libc::c_ushort;
pub type __kernel_gid16_t = libc::c_ushort;
pub type __le16 = __u16;
pub type __be16 = __u16;
pub type __le32 = __u32;
pub type __be32 = __u32;
pub type __le64 = __u64;
pub type __be64 = __u64;
pub type __sum16 = __u16;
pub type __wsum = __u32;
pub type drm_handle_t = libc::c_uint;
pub type drm_context_t = libc::c_uint;
pub type drm_drawable_t = libc::c_uint;
pub type drm_magic_t = libc::c_uint;
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct drm_clip_rect {
    pub x1: libc::c_ushort,
    pub y1: libc::c_ushort,
    pub x2: libc::c_ushort,
    pub y2: libc::c_ushort,
}
#[test]
fn bindgen_test_layout_drm_clip_rect() {
    assert_eq!(::std::mem::size_of::<drm_clip_rect>() , 8usize , concat ! (
               "Size of: " , stringify ! ( drm_clip_rect ) ));
    assert_eq! (::std::mem::align_of::<drm_clip_rect>() , 2usize , concat ! (
                "Alignment of " , stringify ! ( drm_clip_rect ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const drm_clip_rect ) ) . x1 as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( drm_clip_rect ) , "::"
                , stringify ! ( x1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const drm_clip_rect ) ) . y1 as * const _ as
                usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! ( drm_clip_rect ) , "::"
                , stringify ! ( y1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const drm_clip_rect ) ) . x2 as * const _ as
                usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( drm_clip_rect ) , "::"
                , stringify ! ( x2 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const drm_clip_rect ) ) . y2 as * const _ as
                usize } , 6usize , concat ! (
                "Alignment of field: " , stringify ! ( drm_clip_rect ) , "::"
                , stringify ! ( y2 ) ));
}
impl Clone for drm_clip_rect {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct drm_drawable_info {
    pub num_rects: libc::c_uint,
    pub rects: *mut drm_clip_rect,
}
#[test]
fn bindgen_test_layout_drm_drawable_info() {
    assert_eq!(::std::mem::size_of::<drm_drawable_info>() , 16usize , concat !
               ( "Size of: " , stringify ! ( drm_drawable_info ) ));
    assert_eq! (::std::mem::align_of::<drm_drawable_info>() , 8usize , concat
                ! ( "Alignment of " , stringify ! ( drm_drawable_info ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const drm_drawable_info ) ) . num_rects as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( drm_drawable_info ) ,
                "::" , stringify ! ( num_rects ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const drm_drawable_info ) ) . rects as * const
                _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( drm_drawable_info ) ,
                "::" , stringify ! ( rects ) ));
}
impl Clone for drm_drawable_info {
    fn clone(&self) -> Self { *self }
}
impl Default for drm_drawable_info {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct drm_tex_region {
    pub next: libc::c_uchar,
    pub prev: libc::c_uchar,
    pub in_use: libc::c_uchar,
    pub padding: libc::c_uchar,
    pub age: libc::c_uint,
}
#[test]
fn bindgen_test_layout_drm_tex_region() {
    assert_eq!(::std::mem::size_of::<drm_tex_region>() , 8usize , concat ! (
               "Size of: " , stringify ! ( drm_tex_region ) ));
    assert_eq! (::std::mem::align_of::<drm_tex_region>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( drm_tex_region ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const drm_tex_region ) ) . next as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( drm_tex_region ) , "::"
                , stringify ! ( next ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const drm_tex_region ) ) . prev as * const _ as
                usize } , 1usize , concat ! (
                "Alignment of field: " , stringify ! ( drm_tex_region ) , "::"
                , stringify ! ( prev ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const drm_tex_region ) ) . in_use as * const _
                as usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! ( drm_tex_region ) , "::"
                , stringify ! ( in_use ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const drm_tex_region ) ) . padding as * const _
                as usize } , 3usize , concat ! (
                "Alignment of field: " , stringify ! ( drm_tex_region ) , "::"
                , stringify ! ( padding ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const drm_tex_region ) ) . age as * const _ as
                usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( drm_tex_region ) , "::"
                , stringify ! ( age ) ));
}
impl Clone for drm_tex_region {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
pub struct drm_hw_lock {
    pub lock: libc::c_uint,
    pub padding: [libc::c_char; 60usize],
}
#[test]
fn bindgen_test_layout_drm_hw_lock() {
    assert_eq!(::std::mem::size_of::<drm_hw_lock>() , 64usize , concat ! (
               "Size of: " , stringify ! ( drm_hw_lock ) ));
    assert_eq! (::std::mem::align_of::<drm_hw_lock>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( drm_hw_lock ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const drm_hw_lock ) ) . lock as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( drm_hw_lock ) , "::" ,
                stringify ! ( lock ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const drm_hw_lock ) ) . padding as * const _ as
                usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( drm_hw_lock ) , "::" ,
                stringify ! ( padding ) ));
}
impl Default for drm_hw_lock {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct drm_version {
    pub version_major: libc::c_int,
    pub version_minor: libc::c_int,
    pub version_patchlevel: libc::c_int,
    pub name_len: __kernel_size_t,
    pub name: *mut libc::c_char,
    pub date_len: __kernel_size_t,
    pub date: *mut libc::c_char,
    pub desc_len: __kernel_size_t,
    pub desc: *mut libc::c_char,
}
#[test]
fn bindgen_test_layout_drm_version() {
    assert_eq!(::std::mem::size_of::<drm_version>() , 64usize , concat ! (
               "Size of: " , stringify ! ( drm_version ) ));
    assert_eq! (::std::mem::align_of::<drm_version>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( drm_version ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const drm_version ) ) . version_major as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( drm_version ) , "::" ,
                stringify ! ( version_major ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const drm_version ) ) . version_minor as *
                const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( drm_version ) , "::" ,
                stringify ! ( version_minor ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const drm_version ) ) . version_patchlevel as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( drm_version ) , "::" ,
                stringify ! ( version_patchlevel ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const drm_version ) ) . name_len as * const _
                as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( drm_version ) , "::" ,
                stringify ! ( name_len ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const drm_version ) ) . name as * const _ as
                usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( drm_version ) , "::" ,
                stringify ! ( name ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const drm_version ) ) . date_len as * const _
                as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( drm_version ) , "::" ,
                stringify ! ( date_len ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const drm_version ) ) . date as * const _ as
                usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( drm_version ) , "::" ,
                stringify ! ( date ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const drm_version ) ) . desc_len as * const _
                as usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( drm_version ) , "::" ,
                stringify ! ( desc_len ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const drm_version ) ) . desc as * const _ as
                usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( drm_version ) , "::" ,
                stringify ! ( desc ) ));
}
impl Clone for drm_version {
    fn clone(&self) -> Self { *self }
}
impl Default for drm_version {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct drm_unique {
    pub unique_len: __kernel_size_t,
    pub unique: *mut libc::c_char,
}
#[test]
fn bindgen_test_layout_drm_unique() {
    assert_eq!(::std::mem::size_of::<drm_unique>() , 16usize , concat ! (
               "Size of: " , stringify ! ( drm_unique ) ));
    assert_eq! (::std::mem::align_of::<drm_unique>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( drm_unique ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const drm_unique ) ) . unique_len as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( drm_unique ) , "::" ,
                stringify ! ( unique_len ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const drm_unique ) ) . unique as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( drm_unique ) , "::" ,
                stringify ! ( unique ) ));
}
impl Clone for drm_unique {
    fn clone(&self) -> Self { *self }
}
impl Default for drm_unique {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct drm_list {
    pub count: libc::c_int,
    pub version: *mut drm_version,
}
#[test]
fn bindgen_test_layout_drm_list() {
    assert_eq!(::std::mem::size_of::<drm_list>() , 16usize , concat ! (
               "Size of: " , stringify ! ( drm_list ) ));
    assert_eq! (::std::mem::align_of::<drm_list>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( drm_list ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const drm_list ) ) . count as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( drm_list ) , "::" ,
                stringify ! ( count ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const drm_list ) ) . version as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( drm_list ) , "::" ,
                stringify ! ( version ) ));
}
impl Clone for drm_list {
    fn clone(&self) -> Self { *self }
}
impl Default for drm_list {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct drm_block {
    pub unused: libc::c_int,
}
#[test]
fn bindgen_test_layout_drm_block() {
    assert_eq!(::std::mem::size_of::<drm_block>() , 4usize , concat ! (
               "Size of: " , stringify ! ( drm_block ) ));
    assert_eq! (::std::mem::align_of::<drm_block>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( drm_block ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const drm_block ) ) . unused as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( drm_block ) , "::" ,
                stringify ! ( unused ) ));
}
impl Clone for drm_block {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct drm_control {
    pub func: drm_control__bindgen_ty_1,
    pub irq: libc::c_int,
}
pub const drm_control_DRM_ADD_COMMAND: drm_control__bindgen_ty_1 =
    drm_control__bindgen_ty_1::DRM_ADD_COMMAND;
pub const drm_control_DRM_RM_COMMAND: drm_control__bindgen_ty_1 =
    drm_control__bindgen_ty_1::DRM_RM_COMMAND;
pub const drm_control_DRM_INST_HANDLER: drm_control__bindgen_ty_1 =
    drm_control__bindgen_ty_1::DRM_INST_HANDLER;
pub const drm_control_DRM_UNINST_HANDLER: drm_control__bindgen_ty_1 =
    drm_control__bindgen_ty_1::DRM_UNINST_HANDLER;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum drm_control__bindgen_ty_1 {
    DRM_ADD_COMMAND = 0,
    DRM_RM_COMMAND = 1,
    DRM_INST_HANDLER = 2,
    DRM_UNINST_HANDLER = 3,
}
#[test]
fn bindgen_test_layout_drm_control() {
    assert_eq!(::std::mem::size_of::<drm_control>() , 8usize , concat ! (
               "Size of: " , stringify ! ( drm_control ) ));
    assert_eq! (::std::mem::align_of::<drm_control>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( drm_control ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const drm_control ) ) . func as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( drm_control ) , "::" ,
                stringify ! ( func ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const drm_control ) ) . irq as * const _ as
                usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( drm_control ) , "::" ,
                stringify ! ( irq ) ));
}
impl Clone for drm_control {
    fn clone(&self) -> Self { *self }
}
impl Default for drm_control {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum drm_map_type {
    _DRM_FRAME_BUFFER = 0,
    _DRM_REGISTERS = 1,
    _DRM_SHM = 2,
    _DRM_AGP = 3,
    _DRM_SCATTER_GATHER = 4,
    _DRM_CONSISTENT = 5,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum drm_map_flags {
    _DRM_RESTRICTED = 1,
    _DRM_READ_ONLY = 2,
    _DRM_LOCKED = 4,
    _DRM_KERNEL = 8,
    _DRM_WRITE_COMBINING = 16,
    _DRM_CONTAINS_LOCK = 32,
    _DRM_REMOVABLE = 64,
    _DRM_DRIVER = 128,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct drm_ctx_priv_map {
    pub ctx_id: libc::c_uint,
    pub handle: *mut libc::c_void,
}
#[test]
fn bindgen_test_layout_drm_ctx_priv_map() {
    assert_eq!(::std::mem::size_of::<drm_ctx_priv_map>() , 16usize , concat !
               ( "Size of: " , stringify ! ( drm_ctx_priv_map ) ));
    assert_eq! (::std::mem::align_of::<drm_ctx_priv_map>() , 8usize , concat !
                ( "Alignment of " , stringify ! ( drm_ctx_priv_map ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const drm_ctx_priv_map ) ) . ctx_id as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( drm_ctx_priv_map ) ,
                "::" , stringify ! ( ctx_id ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const drm_ctx_priv_map ) ) . handle as * const
                _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( drm_ctx_priv_map ) ,
                "::" , stringify ! ( handle ) ));
}
impl Clone for drm_ctx_priv_map {
    fn clone(&self) -> Self { *self }
}
impl Default for drm_ctx_priv_map {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct drm_map {
    pub offset: libc::c_ulong,
    pub size: libc::c_ulong,
    pub type_: drm_map_type,
    pub flags: drm_map_flags,
    pub handle: *mut libc::c_void,
    pub mtrr: libc::c_int,
}
#[test]
fn bindgen_test_layout_drm_map() {
    assert_eq!(::std::mem::size_of::<drm_map>() , 40usize , concat ! (
               "Size of: " , stringify ! ( drm_map ) ));
    assert_eq! (::std::mem::align_of::<drm_map>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( drm_map ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const drm_map ) ) . offset as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( drm_map ) , "::" ,
                stringify ! ( offset ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const drm_map ) ) . size as * const _ as usize
                } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( drm_map ) , "::" ,
                stringify ! ( size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const drm_map ) ) . type_ as * const _ as usize
                } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( drm_map ) , "::" ,
                stringify ! ( type_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const drm_map ) ) . flags as * const _ as usize
                } , 20usize , concat ! (
                "Alignment of field: " , stringify ! ( drm_map ) , "::" ,
                stringify ! ( flags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const drm_map ) ) . handle as * const _ as
                usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( drm_map ) , "::" ,
                stringify ! ( handle ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const drm_map ) ) . mtrr as * const _ as usize
                } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( drm_map ) , "::" ,
                stringify ! ( mtrr ) ));
}
impl Clone for drm_map {
    fn clone(&self) -> Self { *self }
}
impl Default for drm_map {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct drm_client {
    pub idx: libc::c_int,
    pub auth: libc::c_int,
    pub pid: libc::c_ulong,
    pub uid: libc::c_ulong,
    pub magic: libc::c_ulong,
    pub iocs: libc::c_ulong,
}
#[test]
fn bindgen_test_layout_drm_client() {
    assert_eq!(::std::mem::size_of::<drm_client>() , 40usize , concat ! (
               "Size of: " , stringify ! ( drm_client ) ));
    assert_eq! (::std::mem::align_of::<drm_client>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( drm_client ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const drm_client ) ) . idx as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( drm_client ) , "::" ,
                stringify ! ( idx ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const drm_client ) ) . auth as * const _ as
                usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( drm_client ) , "::" ,
                stringify ! ( auth ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const drm_client ) ) . pid as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( drm_client ) , "::" ,
                stringify ! ( pid ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const drm_client ) ) . uid as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( drm_client ) , "::" ,
                stringify ! ( uid ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const drm_client ) ) . magic as * const _ as
                usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( drm_client ) , "::" ,
                stringify ! ( magic ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const drm_client ) ) . iocs as * const _ as
                usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( drm_client ) , "::" ,
                stringify ! ( iocs ) ));
}
impl Clone for drm_client {
    fn clone(&self) -> Self { *self }
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum drm_stat_type {
    _DRM_STAT_LOCK = 0,
    _DRM_STAT_OPENS = 1,
    _DRM_STAT_CLOSES = 2,
    _DRM_STAT_IOCTLS = 3,
    _DRM_STAT_LOCKS = 4,
    _DRM_STAT_UNLOCKS = 5,
    _DRM_STAT_VALUE = 6,
    _DRM_STAT_BYTE = 7,
    _DRM_STAT_COUNT = 8,
    _DRM_STAT_IRQ = 9,
    _DRM_STAT_PRIMARY = 10,
    _DRM_STAT_SECONDARY = 11,
    _DRM_STAT_DMA = 12,
    _DRM_STAT_SPECIAL = 13,
    _DRM_STAT_MISSED = 14,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct drm_stats {
    pub count: libc::c_ulong,
    pub data: [drm_stats__bindgen_ty_1; 15usize],
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct drm_stats__bindgen_ty_1 {
    pub value: libc::c_ulong,
    pub type_: drm_stat_type,
}
#[test]
fn bindgen_test_layout_drm_stats__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<drm_stats__bindgen_ty_1>() , 16usize ,
               concat ! (
               "Size of: " , stringify ! ( drm_stats__bindgen_ty_1 ) ));
    assert_eq! (::std::mem::align_of::<drm_stats__bindgen_ty_1>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( drm_stats__bindgen_ty_1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const drm_stats__bindgen_ty_1 ) ) . value as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( drm_stats__bindgen_ty_1
                ) , "::" , stringify ! ( value ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const drm_stats__bindgen_ty_1 ) ) . type_ as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( drm_stats__bindgen_ty_1
                ) , "::" , stringify ! ( type_ ) ));
}
impl Clone for drm_stats__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
impl Default for drm_stats__bindgen_ty_1 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[test]
fn bindgen_test_layout_drm_stats() {
    assert_eq!(::std::mem::size_of::<drm_stats>() , 248usize , concat ! (
               "Size of: " , stringify ! ( drm_stats ) ));
    assert_eq! (::std::mem::align_of::<drm_stats>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( drm_stats ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const drm_stats ) ) . count as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( drm_stats ) , "::" ,
                stringify ! ( count ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const drm_stats ) ) . data as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( drm_stats ) , "::" ,
                stringify ! ( data ) ));
}
impl Clone for drm_stats {
    fn clone(&self) -> Self { *self }
}
impl Default for drm_stats {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum drm_lock_flags {
    _DRM_LOCK_READY = 1,
    _DRM_LOCK_QUIESCENT = 2,
    _DRM_LOCK_FLUSH = 4,
    _DRM_LOCK_FLUSH_ALL = 8,
    _DRM_HALT_ALL_QUEUES = 16,
    _DRM_HALT_CUR_QUEUES = 32,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct drm_lock {
    pub context: libc::c_int,
    pub flags: drm_lock_flags,
}
#[test]
fn bindgen_test_layout_drm_lock() {
    assert_eq!(::std::mem::size_of::<drm_lock>() , 8usize , concat ! (
               "Size of: " , stringify ! ( drm_lock ) ));
    assert_eq! (::std::mem::align_of::<drm_lock>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( drm_lock ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const drm_lock ) ) . context as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( drm_lock ) , "::" ,
                stringify ! ( context ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const drm_lock ) ) . flags as * const _ as
                usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( drm_lock ) , "::" ,
                stringify ! ( flags ) ));
}
impl Clone for drm_lock {
    fn clone(&self) -> Self { *self }
}
impl Default for drm_lock {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum drm_dma_flags {
    _DRM_DMA_BLOCK = 1,
    _DRM_DMA_WHILE_LOCKED = 2,
    _DRM_DMA_PRIORITY = 4,
    _DRM_DMA_WAIT = 16,
    _DRM_DMA_SMALLER_OK = 32,
    _DRM_DMA_LARGER_OK = 64,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct drm_buf_desc {
    pub count: libc::c_int,
    pub size: libc::c_int,
    pub low_mark: libc::c_int,
    pub high_mark: libc::c_int,
    pub flags: drm_buf_desc__bindgen_ty_1,
    pub agp_start: libc::c_ulong,
}
pub const drm_buf_desc__DRM_PAGE_ALIGN: drm_buf_desc__bindgen_ty_1 =
    drm_buf_desc__bindgen_ty_1::_DRM_PAGE_ALIGN;
pub const drm_buf_desc__DRM_AGP_BUFFER: drm_buf_desc__bindgen_ty_1 =
    drm_buf_desc__bindgen_ty_1::_DRM_AGP_BUFFER;
pub const drm_buf_desc__DRM_SG_BUFFER: drm_buf_desc__bindgen_ty_1 =
    drm_buf_desc__bindgen_ty_1::_DRM_SG_BUFFER;
pub const drm_buf_desc__DRM_FB_BUFFER: drm_buf_desc__bindgen_ty_1 =
    drm_buf_desc__bindgen_ty_1::_DRM_FB_BUFFER;
pub const drm_buf_desc__DRM_PCI_BUFFER_RO: drm_buf_desc__bindgen_ty_1 =
    drm_buf_desc__bindgen_ty_1::_DRM_PCI_BUFFER_RO;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum drm_buf_desc__bindgen_ty_1 {
    _DRM_PAGE_ALIGN = 1,
    _DRM_AGP_BUFFER = 2,
    _DRM_SG_BUFFER = 4,
    _DRM_FB_BUFFER = 8,
    _DRM_PCI_BUFFER_RO = 16,
}
#[test]
fn bindgen_test_layout_drm_buf_desc() {
    assert_eq!(::std::mem::size_of::<drm_buf_desc>() , 32usize , concat ! (
               "Size of: " , stringify ! ( drm_buf_desc ) ));
    assert_eq! (::std::mem::align_of::<drm_buf_desc>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( drm_buf_desc ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const drm_buf_desc ) ) . count as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( drm_buf_desc ) , "::" ,
                stringify ! ( count ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const drm_buf_desc ) ) . size as * const _ as
                usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( drm_buf_desc ) , "::" ,
                stringify ! ( size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const drm_buf_desc ) ) . low_mark as * const _
                as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( drm_buf_desc ) , "::" ,
                stringify ! ( low_mark ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const drm_buf_desc ) ) . high_mark as * const _
                as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( drm_buf_desc ) , "::" ,
                stringify ! ( high_mark ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const drm_buf_desc ) ) . flags as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( drm_buf_desc ) , "::" ,
                stringify ! ( flags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const drm_buf_desc ) ) . agp_start as * const _
                as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( drm_buf_desc ) , "::" ,
                stringify ! ( agp_start ) ));
}
impl Clone for drm_buf_desc {
    fn clone(&self) -> Self { *self }
}
impl Default for drm_buf_desc {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct drm_buf_info {
    pub count: libc::c_int,
    pub list: *mut drm_buf_desc,
}
#[test]
fn bindgen_test_layout_drm_buf_info() {
    assert_eq!(::std::mem::size_of::<drm_buf_info>() , 16usize , concat ! (
               "Size of: " , stringify ! ( drm_buf_info ) ));
    assert_eq! (::std::mem::align_of::<drm_buf_info>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( drm_buf_info ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const drm_buf_info ) ) . count as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( drm_buf_info ) , "::" ,
                stringify ! ( count ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const drm_buf_info ) ) . list as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( drm_buf_info ) , "::" ,
                stringify ! ( list ) ));
}
impl Clone for drm_buf_info {
    fn clone(&self) -> Self { *self }
}
impl Default for drm_buf_info {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct drm_buf_free {
    pub count: libc::c_int,
    pub list: *mut libc::c_int,
}
#[test]
fn bindgen_test_layout_drm_buf_free() {
    assert_eq!(::std::mem::size_of::<drm_buf_free>() , 16usize , concat ! (
               "Size of: " , stringify ! ( drm_buf_free ) ));
    assert_eq! (::std::mem::align_of::<drm_buf_free>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( drm_buf_free ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const drm_buf_free ) ) . count as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( drm_buf_free ) , "::" ,
                stringify ! ( count ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const drm_buf_free ) ) . list as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( drm_buf_free ) , "::" ,
                stringify ! ( list ) ));
}
impl Clone for drm_buf_free {
    fn clone(&self) -> Self { *self }
}
impl Default for drm_buf_free {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct drm_buf_pub {
    pub idx: libc::c_int,
    pub total: libc::c_int,
    pub used: libc::c_int,
    pub address: *mut libc::c_void,
}
#[test]
fn bindgen_test_layout_drm_buf_pub() {
    assert_eq!(::std::mem::size_of::<drm_buf_pub>() , 24usize , concat ! (
               "Size of: " , stringify ! ( drm_buf_pub ) ));
    assert_eq! (::std::mem::align_of::<drm_buf_pub>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( drm_buf_pub ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const drm_buf_pub ) ) . idx as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( drm_buf_pub ) , "::" ,
                stringify ! ( idx ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const drm_buf_pub ) ) . total as * const _ as
                usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( drm_buf_pub ) , "::" ,
                stringify ! ( total ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const drm_buf_pub ) ) . used as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( drm_buf_pub ) , "::" ,
                stringify ! ( used ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const drm_buf_pub ) ) . address as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( drm_buf_pub ) , "::" ,
                stringify ! ( address ) ));
}
impl Clone for drm_buf_pub {
    fn clone(&self) -> Self { *self }
}
impl Default for drm_buf_pub {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct drm_buf_map {
    pub count: libc::c_int,
    pub virtual_: *mut libc::c_void,
    pub list: *mut drm_buf_pub,
}
#[test]
fn bindgen_test_layout_drm_buf_map() {
    assert_eq!(::std::mem::size_of::<drm_buf_map>() , 24usize , concat ! (
               "Size of: " , stringify ! ( drm_buf_map ) ));
    assert_eq! (::std::mem::align_of::<drm_buf_map>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( drm_buf_map ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const drm_buf_map ) ) . count as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( drm_buf_map ) , "::" ,
                stringify ! ( count ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const drm_buf_map ) ) . virtual_ as * const _
                as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( drm_buf_map ) , "::" ,
                stringify ! ( virtual_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const drm_buf_map ) ) . list as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( drm_buf_map ) , "::" ,
                stringify ! ( list ) ));
}
impl Clone for drm_buf_map {
    fn clone(&self) -> Self { *self }
}
impl Default for drm_buf_map {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct drm_dma {
    pub context: libc::c_int,
    pub send_count: libc::c_int,
    pub send_indices: *mut libc::c_int,
    pub send_sizes: *mut libc::c_int,
    pub flags: drm_dma_flags,
    pub request_count: libc::c_int,
    pub request_size: libc::c_int,
    pub request_indices: *mut libc::c_int,
    pub request_sizes: *mut libc::c_int,
    pub granted_count: libc::c_int,
}
#[test]
fn bindgen_test_layout_drm_dma() {
    assert_eq!(::std::mem::size_of::<drm_dma>() , 64usize , concat ! (
               "Size of: " , stringify ! ( drm_dma ) ));
    assert_eq! (::std::mem::align_of::<drm_dma>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( drm_dma ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const drm_dma ) ) . context as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( drm_dma ) , "::" ,
                stringify ! ( context ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const drm_dma ) ) . send_count as * const _ as
                usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( drm_dma ) , "::" ,
                stringify ! ( send_count ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const drm_dma ) ) . send_indices as * const _
                as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( drm_dma ) , "::" ,
                stringify ! ( send_indices ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const drm_dma ) ) . send_sizes as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( drm_dma ) , "::" ,
                stringify ! ( send_sizes ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const drm_dma ) ) . flags as * const _ as usize
                } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( drm_dma ) , "::" ,
                stringify ! ( flags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const drm_dma ) ) . request_count as * const _
                as usize } , 28usize , concat ! (
                "Alignment of field: " , stringify ! ( drm_dma ) , "::" ,
                stringify ! ( request_count ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const drm_dma ) ) . request_size as * const _
                as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( drm_dma ) , "::" ,
                stringify ! ( request_size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const drm_dma ) ) . request_indices as * const
                _ as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( drm_dma ) , "::" ,
                stringify ! ( request_indices ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const drm_dma ) ) . request_sizes as * const _
                as usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( drm_dma ) , "::" ,
                stringify ! ( request_sizes ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const drm_dma ) ) . granted_count as * const _
                as usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( drm_dma ) , "::" ,
                stringify ! ( granted_count ) ));
}
impl Clone for drm_dma {
    fn clone(&self) -> Self { *self }
}
impl Default for drm_dma {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum drm_ctx_flags {
    _DRM_CONTEXT_PRESERVED = 1,
    _DRM_CONTEXT_2DONLY = 2,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct drm_ctx {
    pub handle: drm_context_t,
    pub flags: drm_ctx_flags,
}
#[test]
fn bindgen_test_layout_drm_ctx() {
    assert_eq!(::std::mem::size_of::<drm_ctx>() , 8usize , concat ! (
               "Size of: " , stringify ! ( drm_ctx ) ));
    assert_eq! (::std::mem::align_of::<drm_ctx>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( drm_ctx ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const drm_ctx ) ) . handle as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( drm_ctx ) , "::" ,
                stringify ! ( handle ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const drm_ctx ) ) . flags as * const _ as usize
                } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( drm_ctx ) , "::" ,
                stringify ! ( flags ) ));
}
impl Clone for drm_ctx {
    fn clone(&self) -> Self { *self }
}
impl Default for drm_ctx {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct drm_ctx_res {
    pub count: libc::c_int,
    pub contexts: *mut drm_ctx,
}
#[test]
fn bindgen_test_layout_drm_ctx_res() {
    assert_eq!(::std::mem::size_of::<drm_ctx_res>() , 16usize , concat ! (
               "Size of: " , stringify ! ( drm_ctx_res ) ));
    assert_eq! (::std::mem::align_of::<drm_ctx_res>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( drm_ctx_res ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const drm_ctx_res ) ) . count as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( drm_ctx_res ) , "::" ,
                stringify ! ( count ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const drm_ctx_res ) ) . contexts as * const _
                as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( drm_ctx_res ) , "::" ,
                stringify ! ( contexts ) ));
}
impl Clone for drm_ctx_res {
    fn clone(&self) -> Self { *self }
}
impl Default for drm_ctx_res {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct drm_draw {
    pub handle: drm_drawable_t,
}
#[test]
fn bindgen_test_layout_drm_draw() {
    assert_eq!(::std::mem::size_of::<drm_draw>() , 4usize , concat ! (
               "Size of: " , stringify ! ( drm_draw ) ));
    assert_eq! (::std::mem::align_of::<drm_draw>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( drm_draw ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const drm_draw ) ) . handle as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( drm_draw ) , "::" ,
                stringify ! ( handle ) ));
}
impl Clone for drm_draw {
    fn clone(&self) -> Self { *self }
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum drm_drawable_info_type_t { DRM_DRAWABLE_CLIPRECTS = 0, }
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct drm_update_draw {
    pub handle: drm_drawable_t,
    pub type_: libc::c_uint,
    pub num: libc::c_uint,
    pub data: libc::c_ulonglong,
}
#[test]
fn bindgen_test_layout_drm_update_draw() {
    assert_eq!(::std::mem::size_of::<drm_update_draw>() , 24usize , concat ! (
               "Size of: " , stringify ! ( drm_update_draw ) ));
    assert_eq! (::std::mem::align_of::<drm_update_draw>() , 8usize , concat !
                ( "Alignment of " , stringify ! ( drm_update_draw ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const drm_update_draw ) ) . handle as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( drm_update_draw ) ,
                "::" , stringify ! ( handle ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const drm_update_draw ) ) . type_ as * const _
                as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( drm_update_draw ) ,
                "::" , stringify ! ( type_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const drm_update_draw ) ) . num as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( drm_update_draw ) ,
                "::" , stringify ! ( num ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const drm_update_draw ) ) . data as * const _
                as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( drm_update_draw ) ,
                "::" , stringify ! ( data ) ));
}
impl Clone for drm_update_draw {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct drm_auth {
    pub magic: drm_magic_t,
}
#[test]
fn bindgen_test_layout_drm_auth() {
    assert_eq!(::std::mem::size_of::<drm_auth>() , 4usize , concat ! (
               "Size of: " , stringify ! ( drm_auth ) ));
    assert_eq! (::std::mem::align_of::<drm_auth>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( drm_auth ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const drm_auth ) ) . magic as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( drm_auth ) , "::" ,
                stringify ! ( magic ) ));
}
impl Clone for drm_auth {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct drm_irq_busid {
    pub irq: libc::c_int,
    pub busnum: libc::c_int,
    pub devnum: libc::c_int,
    pub funcnum: libc::c_int,
}
#[test]
fn bindgen_test_layout_drm_irq_busid() {
    assert_eq!(::std::mem::size_of::<drm_irq_busid>() , 16usize , concat ! (
               "Size of: " , stringify ! ( drm_irq_busid ) ));
    assert_eq! (::std::mem::align_of::<drm_irq_busid>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( drm_irq_busid ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const drm_irq_busid ) ) . irq as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( drm_irq_busid ) , "::"
                , stringify ! ( irq ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const drm_irq_busid ) ) . busnum as * const _
                as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( drm_irq_busid ) , "::"
                , stringify ! ( busnum ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const drm_irq_busid ) ) . devnum as * const _
                as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( drm_irq_busid ) , "::"
                , stringify ! ( devnum ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const drm_irq_busid ) ) . funcnum as * const _
                as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( drm_irq_busid ) , "::"
                , stringify ! ( funcnum ) ));
}
impl Clone for drm_irq_busid {
    fn clone(&self) -> Self { *self }
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum drm_vblank_seq_type {
    _DRM_VBLANK_ABSOLUTE = 0,
    _DRM_VBLANK_RELATIVE = 1,
    _DRM_VBLANK_HIGH_CRTC_MASK = 62,
    _DRM_VBLANK_EVENT = 67108864,
    _DRM_VBLANK_FLIP = 134217728,
    _DRM_VBLANK_NEXTONMISS = 268435456,
    _DRM_VBLANK_SECONDARY = 536870912,
    _DRM_VBLANK_SIGNAL = 1073741824,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct drm_wait_vblank_request {
    pub type_: drm_vblank_seq_type,
    pub sequence: libc::c_uint,
    pub signal: libc::c_ulong,
}
#[test]
fn bindgen_test_layout_drm_wait_vblank_request() {
    assert_eq!(::std::mem::size_of::<drm_wait_vblank_request>() , 16usize ,
               concat ! (
               "Size of: " , stringify ! ( drm_wait_vblank_request ) ));
    assert_eq! (::std::mem::align_of::<drm_wait_vblank_request>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( drm_wait_vblank_request ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const drm_wait_vblank_request ) ) . type_ as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( drm_wait_vblank_request
                ) , "::" , stringify ! ( type_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const drm_wait_vblank_request ) ) . sequence as
                * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( drm_wait_vblank_request
                ) , "::" , stringify ! ( sequence ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const drm_wait_vblank_request ) ) . signal as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( drm_wait_vblank_request
                ) , "::" , stringify ! ( signal ) ));
}
impl Clone for drm_wait_vblank_request {
    fn clone(&self) -> Self { *self }
}
impl Default for drm_wait_vblank_request {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct drm_wait_vblank_reply {
    pub type_: drm_vblank_seq_type,
    pub sequence: libc::c_uint,
    pub tval_sec: libc::c_long,
    pub tval_usec: libc::c_long,
}
#[test]
fn bindgen_test_layout_drm_wait_vblank_reply() {
    assert_eq!(::std::mem::size_of::<drm_wait_vblank_reply>() , 24usize ,
               concat ! ( "Size of: " , stringify ! ( drm_wait_vblank_reply )
               ));
    assert_eq! (::std::mem::align_of::<drm_wait_vblank_reply>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( drm_wait_vblank_reply ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const drm_wait_vblank_reply ) ) . type_ as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( drm_wait_vblank_reply )
                , "::" , stringify ! ( type_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const drm_wait_vblank_reply ) ) . sequence as *
                const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( drm_wait_vblank_reply )
                , "::" , stringify ! ( sequence ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const drm_wait_vblank_reply ) ) . tval_sec as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( drm_wait_vblank_reply )
                , "::" , stringify ! ( tval_sec ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const drm_wait_vblank_reply ) ) . tval_usec as
                * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( drm_wait_vblank_reply )
                , "::" , stringify ! ( tval_usec ) ));
}
impl Clone for drm_wait_vblank_reply {
    fn clone(&self) -> Self { *self }
}
impl Default for drm_wait_vblank_reply {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct drm_wait_vblank {
    pub request: __BindgenUnionField<drm_wait_vblank_request>,
    pub reply: __BindgenUnionField<drm_wait_vblank_reply>,
    pub bindgen_union_field: [u64; 3usize],
}
#[test]
fn bindgen_test_layout_drm_wait_vblank() {
    assert_eq!(::std::mem::size_of::<drm_wait_vblank>() , 24usize , concat ! (
               "Size of: " , stringify ! ( drm_wait_vblank ) ));
    assert_eq! (::std::mem::align_of::<drm_wait_vblank>() , 8usize , concat !
                ( "Alignment of " , stringify ! ( drm_wait_vblank ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const drm_wait_vblank ) ) . request as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( drm_wait_vblank ) ,
                "::" , stringify ! ( request ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const drm_wait_vblank ) ) . reply as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( drm_wait_vblank ) ,
                "::" , stringify ! ( reply ) ));
}
impl Clone for drm_wait_vblank {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct drm_modeset_ctl {
    pub crtc: __u32,
    pub cmd: __u32,
}
#[test]
fn bindgen_test_layout_drm_modeset_ctl() {
    assert_eq!(::std::mem::size_of::<drm_modeset_ctl>() , 8usize , concat ! (
               "Size of: " , stringify ! ( drm_modeset_ctl ) ));
    assert_eq! (::std::mem::align_of::<drm_modeset_ctl>() , 4usize , concat !
                ( "Alignment of " , stringify ! ( drm_modeset_ctl ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const drm_modeset_ctl ) ) . crtc as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( drm_modeset_ctl ) ,
                "::" , stringify ! ( crtc ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const drm_modeset_ctl ) ) . cmd as * const _ as
                usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( drm_modeset_ctl ) ,
                "::" , stringify ! ( cmd ) ));
}
impl Clone for drm_modeset_ctl {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct drm_agp_mode {
    pub mode: libc::c_ulong,
}
#[test]
fn bindgen_test_layout_drm_agp_mode() {
    assert_eq!(::std::mem::size_of::<drm_agp_mode>() , 8usize , concat ! (
               "Size of: " , stringify ! ( drm_agp_mode ) ));
    assert_eq! (::std::mem::align_of::<drm_agp_mode>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( drm_agp_mode ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const drm_agp_mode ) ) . mode as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( drm_agp_mode ) , "::" ,
                stringify ! ( mode ) ));
}
impl Clone for drm_agp_mode {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct drm_agp_buffer {
    pub size: libc::c_ulong,
    pub handle: libc::c_ulong,
    pub type_: libc::c_ulong,
    pub physical: libc::c_ulong,
}
#[test]
fn bindgen_test_layout_drm_agp_buffer() {
    assert_eq!(::std::mem::size_of::<drm_agp_buffer>() , 32usize , concat ! (
               "Size of: " , stringify ! ( drm_agp_buffer ) ));
    assert_eq! (::std::mem::align_of::<drm_agp_buffer>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( drm_agp_buffer ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const drm_agp_buffer ) ) . size as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( drm_agp_buffer ) , "::"
                , stringify ! ( size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const drm_agp_buffer ) ) . handle as * const _
                as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( drm_agp_buffer ) , "::"
                , stringify ! ( handle ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const drm_agp_buffer ) ) . type_ as * const _
                as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( drm_agp_buffer ) , "::"
                , stringify ! ( type_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const drm_agp_buffer ) ) . physical as * const
                _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( drm_agp_buffer ) , "::"
                , stringify ! ( physical ) ));
}
impl Clone for drm_agp_buffer {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct drm_agp_binding {
    pub handle: libc::c_ulong,
    pub offset: libc::c_ulong,
}
#[test]
fn bindgen_test_layout_drm_agp_binding() {
    assert_eq!(::std::mem::size_of::<drm_agp_binding>() , 16usize , concat ! (
               "Size of: " , stringify ! ( drm_agp_binding ) ));
    assert_eq! (::std::mem::align_of::<drm_agp_binding>() , 8usize , concat !
                ( "Alignment of " , stringify ! ( drm_agp_binding ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const drm_agp_binding ) ) . handle as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( drm_agp_binding ) ,
                "::" , stringify ! ( handle ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const drm_agp_binding ) ) . offset as * const _
                as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( drm_agp_binding ) ,
                "::" , stringify ! ( offset ) ));
}
impl Clone for drm_agp_binding {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct drm_agp_info {
    pub agp_version_major: libc::c_int,
    pub agp_version_minor: libc::c_int,
    pub mode: libc::c_ulong,
    pub aperture_base: libc::c_ulong,
    pub aperture_size: libc::c_ulong,
    pub memory_allowed: libc::c_ulong,
    pub memory_used: libc::c_ulong,
    pub id_vendor: libc::c_ushort,
    pub id_device: libc::c_ushort,
}
#[test]
fn bindgen_test_layout_drm_agp_info() {
    assert_eq!(::std::mem::size_of::<drm_agp_info>() , 56usize , concat ! (
               "Size of: " , stringify ! ( drm_agp_info ) ));
    assert_eq! (::std::mem::align_of::<drm_agp_info>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( drm_agp_info ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const drm_agp_info ) ) . agp_version_major as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( drm_agp_info ) , "::" ,
                stringify ! ( agp_version_major ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const drm_agp_info ) ) . agp_version_minor as *
                const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( drm_agp_info ) , "::" ,
                stringify ! ( agp_version_minor ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const drm_agp_info ) ) . mode as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( drm_agp_info ) , "::" ,
                stringify ! ( mode ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const drm_agp_info ) ) . aperture_base as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( drm_agp_info ) , "::" ,
                stringify ! ( aperture_base ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const drm_agp_info ) ) . aperture_size as *
                const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( drm_agp_info ) , "::" ,
                stringify ! ( aperture_size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const drm_agp_info ) ) . memory_allowed as *
                const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( drm_agp_info ) , "::" ,
                stringify ! ( memory_allowed ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const drm_agp_info ) ) . memory_used as * const
                _ as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( drm_agp_info ) , "::" ,
                stringify ! ( memory_used ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const drm_agp_info ) ) . id_vendor as * const _
                as usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( drm_agp_info ) , "::" ,
                stringify ! ( id_vendor ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const drm_agp_info ) ) . id_device as * const _
                as usize } , 50usize , concat ! (
                "Alignment of field: " , stringify ! ( drm_agp_info ) , "::" ,
                stringify ! ( id_device ) ));
}
impl Clone for drm_agp_info {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct drm_scatter_gather {
    pub size: libc::c_ulong,
    pub handle: libc::c_ulong,
}
#[test]
fn bindgen_test_layout_drm_scatter_gather() {
    assert_eq!(::std::mem::size_of::<drm_scatter_gather>() , 16usize , concat
               ! ( "Size of: " , stringify ! ( drm_scatter_gather ) ));
    assert_eq! (::std::mem::align_of::<drm_scatter_gather>() , 8usize , concat
                ! ( "Alignment of " , stringify ! ( drm_scatter_gather ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const drm_scatter_gather ) ) . size as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( drm_scatter_gather ) ,
                "::" , stringify ! ( size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const drm_scatter_gather ) ) . handle as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( drm_scatter_gather ) ,
                "::" , stringify ! ( handle ) ));
}
impl Clone for drm_scatter_gather {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct drm_set_version {
    pub drm_di_major: libc::c_int,
    pub drm_di_minor: libc::c_int,
    pub drm_dd_major: libc::c_int,
    pub drm_dd_minor: libc::c_int,
}
#[test]
fn bindgen_test_layout_drm_set_version() {
    assert_eq!(::std::mem::size_of::<drm_set_version>() , 16usize , concat ! (
               "Size of: " , stringify ! ( drm_set_version ) ));
    assert_eq! (::std::mem::align_of::<drm_set_version>() , 4usize , concat !
                ( "Alignment of " , stringify ! ( drm_set_version ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const drm_set_version ) ) . drm_di_major as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( drm_set_version ) ,
                "::" , stringify ! ( drm_di_major ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const drm_set_version ) ) . drm_di_minor as *
                const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( drm_set_version ) ,
                "::" , stringify ! ( drm_di_minor ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const drm_set_version ) ) . drm_dd_major as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( drm_set_version ) ,
                "::" , stringify ! ( drm_dd_major ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const drm_set_version ) ) . drm_dd_minor as *
                const _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( drm_set_version ) ,
                "::" , stringify ! ( drm_dd_minor ) ));
}
impl Clone for drm_set_version {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct drm_gem_close {
    pub handle: __u32,
    pub pad: __u32,
}
#[test]
fn bindgen_test_layout_drm_gem_close() {
    assert_eq!(::std::mem::size_of::<drm_gem_close>() , 8usize , concat ! (
               "Size of: " , stringify ! ( drm_gem_close ) ));
    assert_eq! (::std::mem::align_of::<drm_gem_close>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( drm_gem_close ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const drm_gem_close ) ) . handle as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( drm_gem_close ) , "::"
                , stringify ! ( handle ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const drm_gem_close ) ) . pad as * const _ as
                usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( drm_gem_close ) , "::"
                , stringify ! ( pad ) ));
}
impl Clone for drm_gem_close {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct drm_gem_flink {
    pub handle: __u32,
    pub name: __u32,
}
#[test]
fn bindgen_test_layout_drm_gem_flink() {
    assert_eq!(::std::mem::size_of::<drm_gem_flink>() , 8usize , concat ! (
               "Size of: " , stringify ! ( drm_gem_flink ) ));
    assert_eq! (::std::mem::align_of::<drm_gem_flink>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( drm_gem_flink ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const drm_gem_flink ) ) . handle as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( drm_gem_flink ) , "::"
                , stringify ! ( handle ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const drm_gem_flink ) ) . name as * const _ as
                usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( drm_gem_flink ) , "::"
                , stringify ! ( name ) ));
}
impl Clone for drm_gem_flink {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct drm_gem_open {
    pub name: __u32,
    pub handle: __u32,
    pub size: __u64,
}
#[test]
fn bindgen_test_layout_drm_gem_open() {
    assert_eq!(::std::mem::size_of::<drm_gem_open>() , 16usize , concat ! (
               "Size of: " , stringify ! ( drm_gem_open ) ));
    assert_eq! (::std::mem::align_of::<drm_gem_open>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( drm_gem_open ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const drm_gem_open ) ) . name as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( drm_gem_open ) , "::" ,
                stringify ! ( name ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const drm_gem_open ) ) . handle as * const _ as
                usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( drm_gem_open ) , "::" ,
                stringify ! ( handle ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const drm_gem_open ) ) . size as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( drm_gem_open ) , "::" ,
                stringify ! ( size ) ));
}
impl Clone for drm_gem_open {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct drm_get_cap {
    pub capability: __u64,
    pub value: __u64,
}
#[test]
fn bindgen_test_layout_drm_get_cap() {
    assert_eq!(::std::mem::size_of::<drm_get_cap>() , 16usize , concat ! (
               "Size of: " , stringify ! ( drm_get_cap ) ));
    assert_eq! (::std::mem::align_of::<drm_get_cap>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( drm_get_cap ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const drm_get_cap ) ) . capability as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( drm_get_cap ) , "::" ,
                stringify ! ( capability ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const drm_get_cap ) ) . value as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( drm_get_cap ) , "::" ,
                stringify ! ( value ) ));
}
impl Clone for drm_get_cap {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct drm_set_client_cap {
    pub capability: __u64,
    pub value: __u64,
}
#[test]
fn bindgen_test_layout_drm_set_client_cap() {
    assert_eq!(::std::mem::size_of::<drm_set_client_cap>() , 16usize , concat
               ! ( "Size of: " , stringify ! ( drm_set_client_cap ) ));
    assert_eq! (::std::mem::align_of::<drm_set_client_cap>() , 8usize , concat
                ! ( "Alignment of " , stringify ! ( drm_set_client_cap ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const drm_set_client_cap ) ) . capability as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( drm_set_client_cap ) ,
                "::" , stringify ! ( capability ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const drm_set_client_cap ) ) . value as * const
                _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( drm_set_client_cap ) ,
                "::" , stringify ! ( value ) ));
}
impl Clone for drm_set_client_cap {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct drm_prime_handle {
    pub handle: __u32,
    pub flags: __u32,
    pub fd: __s32,
}
#[test]
fn bindgen_test_layout_drm_prime_handle() {
    assert_eq!(::std::mem::size_of::<drm_prime_handle>() , 12usize , concat !
               ( "Size of: " , stringify ! ( drm_prime_handle ) ));
    assert_eq! (::std::mem::align_of::<drm_prime_handle>() , 4usize , concat !
                ( "Alignment of " , stringify ! ( drm_prime_handle ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const drm_prime_handle ) ) . handle as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( drm_prime_handle ) ,
                "::" , stringify ! ( handle ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const drm_prime_handle ) ) . flags as * const _
                as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( drm_prime_handle ) ,
                "::" , stringify ! ( flags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const drm_prime_handle ) ) . fd as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( drm_prime_handle ) ,
                "::" , stringify ! ( fd ) ));
}
impl Clone for drm_prime_handle {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct drm_mode_modeinfo {
    pub clock: __u32,
    pub hdisplay: __u16,
    pub hsync_start: __u16,
    pub hsync_end: __u16,
    pub htotal: __u16,
    pub hskew: __u16,
    pub vdisplay: __u16,
    pub vsync_start: __u16,
    pub vsync_end: __u16,
    pub vtotal: __u16,
    pub vscan: __u16,
    pub vrefresh: __u32,
    pub flags: __u32,
    pub type_: __u32,
    pub name: [libc::c_char; 32usize],
}
#[test]
fn bindgen_test_layout_drm_mode_modeinfo() {
    assert_eq!(::std::mem::size_of::<drm_mode_modeinfo>() , 68usize , concat !
               ( "Size of: " , stringify ! ( drm_mode_modeinfo ) ));
    assert_eq! (::std::mem::align_of::<drm_mode_modeinfo>() , 4usize , concat
                ! ( "Alignment of " , stringify ! ( drm_mode_modeinfo ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const drm_mode_modeinfo ) ) . clock as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( drm_mode_modeinfo ) ,
                "::" , stringify ! ( clock ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const drm_mode_modeinfo ) ) . hdisplay as *
                const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( drm_mode_modeinfo ) ,
                "::" , stringify ! ( hdisplay ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const drm_mode_modeinfo ) ) . hsync_start as *
                const _ as usize } , 6usize , concat ! (
                "Alignment of field: " , stringify ! ( drm_mode_modeinfo ) ,
                "::" , stringify ! ( hsync_start ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const drm_mode_modeinfo ) ) . hsync_end as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( drm_mode_modeinfo ) ,
                "::" , stringify ! ( hsync_end ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const drm_mode_modeinfo ) ) . htotal as * const
                _ as usize } , 10usize , concat ! (
                "Alignment of field: " , stringify ! ( drm_mode_modeinfo ) ,
                "::" , stringify ! ( htotal ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const drm_mode_modeinfo ) ) . hskew as * const
                _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( drm_mode_modeinfo ) ,
                "::" , stringify ! ( hskew ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const drm_mode_modeinfo ) ) . vdisplay as *
                const _ as usize } , 14usize , concat ! (
                "Alignment of field: " , stringify ! ( drm_mode_modeinfo ) ,
                "::" , stringify ! ( vdisplay ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const drm_mode_modeinfo ) ) . vsync_start as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( drm_mode_modeinfo ) ,
                "::" , stringify ! ( vsync_start ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const drm_mode_modeinfo ) ) . vsync_end as *
                const _ as usize } , 18usize , concat ! (
                "Alignment of field: " , stringify ! ( drm_mode_modeinfo ) ,
                "::" , stringify ! ( vsync_end ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const drm_mode_modeinfo ) ) . vtotal as * const
                _ as usize } , 20usize , concat ! (
                "Alignment of field: " , stringify ! ( drm_mode_modeinfo ) ,
                "::" , stringify ! ( vtotal ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const drm_mode_modeinfo ) ) . vscan as * const
                _ as usize } , 22usize , concat ! (
                "Alignment of field: " , stringify ! ( drm_mode_modeinfo ) ,
                "::" , stringify ! ( vscan ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const drm_mode_modeinfo ) ) . vrefresh as *
                const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( drm_mode_modeinfo ) ,
                "::" , stringify ! ( vrefresh ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const drm_mode_modeinfo ) ) . flags as * const
                _ as usize } , 28usize , concat ! (
                "Alignment of field: " , stringify ! ( drm_mode_modeinfo ) ,
                "::" , stringify ! ( flags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const drm_mode_modeinfo ) ) . type_ as * const
                _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( drm_mode_modeinfo ) ,
                "::" , stringify ! ( type_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const drm_mode_modeinfo ) ) . name as * const _
                as usize } , 36usize , concat ! (
                "Alignment of field: " , stringify ! ( drm_mode_modeinfo ) ,
                "::" , stringify ! ( name ) ));
}
impl Clone for drm_mode_modeinfo {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct drm_mode_card_res {
    pub fb_id_ptr: __u64,
    pub crtc_id_ptr: __u64,
    pub connector_id_ptr: __u64,
    pub encoder_id_ptr: __u64,
    pub count_fbs: __u32,
    pub count_crtcs: __u32,
    pub count_connectors: __u32,
    pub count_encoders: __u32,
    pub min_width: __u32,
    pub max_width: __u32,
    pub min_height: __u32,
    pub max_height: __u32,
}
#[test]
fn bindgen_test_layout_drm_mode_card_res() {
    assert_eq!(::std::mem::size_of::<drm_mode_card_res>() , 64usize , concat !
               ( "Size of: " , stringify ! ( drm_mode_card_res ) ));
    assert_eq! (::std::mem::align_of::<drm_mode_card_res>() , 8usize , concat
                ! ( "Alignment of " , stringify ! ( drm_mode_card_res ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const drm_mode_card_res ) ) . fb_id_ptr as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( drm_mode_card_res ) ,
                "::" , stringify ! ( fb_id_ptr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const drm_mode_card_res ) ) . crtc_id_ptr as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( drm_mode_card_res ) ,
                "::" , stringify ! ( crtc_id_ptr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const drm_mode_card_res ) ) . connector_id_ptr
                as * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( drm_mode_card_res ) ,
                "::" , stringify ! ( connector_id_ptr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const drm_mode_card_res ) ) . encoder_id_ptr as
                * const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( drm_mode_card_res ) ,
                "::" , stringify ! ( encoder_id_ptr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const drm_mode_card_res ) ) . count_fbs as *
                const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( drm_mode_card_res ) ,
                "::" , stringify ! ( count_fbs ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const drm_mode_card_res ) ) . count_crtcs as *
                const _ as usize } , 36usize , concat ! (
                "Alignment of field: " , stringify ! ( drm_mode_card_res ) ,
                "::" , stringify ! ( count_crtcs ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const drm_mode_card_res ) ) . count_connectors
                as * const _ as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( drm_mode_card_res ) ,
                "::" , stringify ! ( count_connectors ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const drm_mode_card_res ) ) . count_encoders as
                * const _ as usize } , 44usize , concat ! (
                "Alignment of field: " , stringify ! ( drm_mode_card_res ) ,
                "::" , stringify ! ( count_encoders ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const drm_mode_card_res ) ) . min_width as *
                const _ as usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( drm_mode_card_res ) ,
                "::" , stringify ! ( min_width ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const drm_mode_card_res ) ) . max_width as *
                const _ as usize } , 52usize , concat ! (
                "Alignment of field: " , stringify ! ( drm_mode_card_res ) ,
                "::" , stringify ! ( max_width ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const drm_mode_card_res ) ) . min_height as *
                const _ as usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( drm_mode_card_res ) ,
                "::" , stringify ! ( min_height ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const drm_mode_card_res ) ) . max_height as *
                const _ as usize } , 60usize , concat ! (
                "Alignment of field: " , stringify ! ( drm_mode_card_res ) ,
                "::" , stringify ! ( max_height ) ));
}
impl Clone for drm_mode_card_res {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct drm_mode_crtc {
    pub set_connectors_ptr: __u64,
    pub count_connectors: __u32,
    pub crtc_id: __u32,
    pub fb_id: __u32,
    pub x: __u32,
    pub y: __u32,
    pub gamma_size: __u32,
    pub mode_valid: __u32,
    pub mode: drm_mode_modeinfo,
}
#[test]
fn bindgen_test_layout_drm_mode_crtc() {
    assert_eq!(::std::mem::size_of::<drm_mode_crtc>() , 104usize , concat ! (
               "Size of: " , stringify ! ( drm_mode_crtc ) ));
    assert_eq! (::std::mem::align_of::<drm_mode_crtc>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( drm_mode_crtc ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const drm_mode_crtc ) ) . set_connectors_ptr as
                * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( drm_mode_crtc ) , "::"
                , stringify ! ( set_connectors_ptr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const drm_mode_crtc ) ) . count_connectors as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( drm_mode_crtc ) , "::"
                , stringify ! ( count_connectors ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const drm_mode_crtc ) ) . crtc_id as * const _
                as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( drm_mode_crtc ) , "::"
                , stringify ! ( crtc_id ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const drm_mode_crtc ) ) . fb_id as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( drm_mode_crtc ) , "::"
                , stringify ! ( fb_id ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const drm_mode_crtc ) ) . x as * const _ as
                usize } , 20usize , concat ! (
                "Alignment of field: " , stringify ! ( drm_mode_crtc ) , "::"
                , stringify ! ( x ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const drm_mode_crtc ) ) . y as * const _ as
                usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( drm_mode_crtc ) , "::"
                , stringify ! ( y ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const drm_mode_crtc ) ) . gamma_size as * const
                _ as usize } , 28usize , concat ! (
                "Alignment of field: " , stringify ! ( drm_mode_crtc ) , "::"
                , stringify ! ( gamma_size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const drm_mode_crtc ) ) . mode_valid as * const
                _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( drm_mode_crtc ) , "::"
                , stringify ! ( mode_valid ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const drm_mode_crtc ) ) . mode as * const _ as
                usize } , 36usize , concat ! (
                "Alignment of field: " , stringify ! ( drm_mode_crtc ) , "::"
                , stringify ! ( mode ) ));
}
impl Clone for drm_mode_crtc {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct drm_mode_set_plane {
    pub plane_id: __u32,
    pub crtc_id: __u32,
    pub fb_id: __u32,
    pub flags: __u32,
    pub crtc_x: __s32,
    pub crtc_y: __s32,
    pub crtc_w: __u32,
    pub crtc_h: __u32,
    pub src_x: __u32,
    pub src_y: __u32,
    pub src_h: __u32,
    pub src_w: __u32,
}
#[test]
fn bindgen_test_layout_drm_mode_set_plane() {
    assert_eq!(::std::mem::size_of::<drm_mode_set_plane>() , 48usize , concat
               ! ( "Size of: " , stringify ! ( drm_mode_set_plane ) ));
    assert_eq! (::std::mem::align_of::<drm_mode_set_plane>() , 4usize , concat
                ! ( "Alignment of " , stringify ! ( drm_mode_set_plane ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const drm_mode_set_plane ) ) . plane_id as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( drm_mode_set_plane ) ,
                "::" , stringify ! ( plane_id ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const drm_mode_set_plane ) ) . crtc_id as *
                const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( drm_mode_set_plane ) ,
                "::" , stringify ! ( crtc_id ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const drm_mode_set_plane ) ) . fb_id as * const
                _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( drm_mode_set_plane ) ,
                "::" , stringify ! ( fb_id ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const drm_mode_set_plane ) ) . flags as * const
                _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( drm_mode_set_plane ) ,
                "::" , stringify ! ( flags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const drm_mode_set_plane ) ) . crtc_x as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( drm_mode_set_plane ) ,
                "::" , stringify ! ( crtc_x ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const drm_mode_set_plane ) ) . crtc_y as *
                const _ as usize } , 20usize , concat ! (
                "Alignment of field: " , stringify ! ( drm_mode_set_plane ) ,
                "::" , stringify ! ( crtc_y ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const drm_mode_set_plane ) ) . crtc_w as *
                const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( drm_mode_set_plane ) ,
                "::" , stringify ! ( crtc_w ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const drm_mode_set_plane ) ) . crtc_h as *
                const _ as usize } , 28usize , concat ! (
                "Alignment of field: " , stringify ! ( drm_mode_set_plane ) ,
                "::" , stringify ! ( crtc_h ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const drm_mode_set_plane ) ) . src_x as * const
                _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( drm_mode_set_plane ) ,
                "::" , stringify ! ( src_x ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const drm_mode_set_plane ) ) . src_y as * const
                _ as usize } , 36usize , concat ! (
                "Alignment of field: " , stringify ! ( drm_mode_set_plane ) ,
                "::" , stringify ! ( src_y ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const drm_mode_set_plane ) ) . src_h as * const
                _ as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( drm_mode_set_plane ) ,
                "::" , stringify ! ( src_h ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const drm_mode_set_plane ) ) . src_w as * const
                _ as usize } , 44usize , concat ! (
                "Alignment of field: " , stringify ! ( drm_mode_set_plane ) ,
                "::" , stringify ! ( src_w ) ));
}
impl Clone for drm_mode_set_plane {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct drm_mode_get_plane {
    pub plane_id: __u32,
    pub crtc_id: __u32,
    pub fb_id: __u32,
    pub possible_crtcs: __u32,
    pub gamma_size: __u32,
    pub count_format_types: __u32,
    pub format_type_ptr: __u64,
}
#[test]
fn bindgen_test_layout_drm_mode_get_plane() {
    assert_eq!(::std::mem::size_of::<drm_mode_get_plane>() , 32usize , concat
               ! ( "Size of: " , stringify ! ( drm_mode_get_plane ) ));
    assert_eq! (::std::mem::align_of::<drm_mode_get_plane>() , 8usize , concat
                ! ( "Alignment of " , stringify ! ( drm_mode_get_plane ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const drm_mode_get_plane ) ) . plane_id as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( drm_mode_get_plane ) ,
                "::" , stringify ! ( plane_id ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const drm_mode_get_plane ) ) . crtc_id as *
                const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( drm_mode_get_plane ) ,
                "::" , stringify ! ( crtc_id ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const drm_mode_get_plane ) ) . fb_id as * const
                _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( drm_mode_get_plane ) ,
                "::" , stringify ! ( fb_id ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const drm_mode_get_plane ) ) . possible_crtcs
                as * const _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( drm_mode_get_plane ) ,
                "::" , stringify ! ( possible_crtcs ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const drm_mode_get_plane ) ) . gamma_size as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( drm_mode_get_plane ) ,
                "::" , stringify ! ( gamma_size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const drm_mode_get_plane ) ) .
                count_format_types as * const _ as usize } , 20usize , concat
                ! (
                "Alignment of field: " , stringify ! ( drm_mode_get_plane ) ,
                "::" , stringify ! ( count_format_types ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const drm_mode_get_plane ) ) . format_type_ptr
                as * const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( drm_mode_get_plane ) ,
                "::" , stringify ! ( format_type_ptr ) ));
}
impl Clone for drm_mode_get_plane {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct drm_mode_get_plane_res {
    pub plane_id_ptr: __u64,
    pub count_planes: __u32,
}
#[test]
fn bindgen_test_layout_drm_mode_get_plane_res() {
    assert_eq!(::std::mem::size_of::<drm_mode_get_plane_res>() , 16usize ,
               concat ! ( "Size of: " , stringify ! ( drm_mode_get_plane_res )
               ));
    assert_eq! (::std::mem::align_of::<drm_mode_get_plane_res>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( drm_mode_get_plane_res ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const drm_mode_get_plane_res ) ) . plane_id_ptr
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( drm_mode_get_plane_res
                ) , "::" , stringify ! ( plane_id_ptr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const drm_mode_get_plane_res ) ) . count_planes
                as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( drm_mode_get_plane_res
                ) , "::" , stringify ! ( count_planes ) ));
}
impl Clone for drm_mode_get_plane_res {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct drm_mode_get_encoder {
    pub encoder_id: __u32,
    pub encoder_type: __u32,
    pub crtc_id: __u32,
    pub possible_crtcs: __u32,
    pub possible_clones: __u32,
}
#[test]
fn bindgen_test_layout_drm_mode_get_encoder() {
    assert_eq!(::std::mem::size_of::<drm_mode_get_encoder>() , 20usize ,
               concat ! ( "Size of: " , stringify ! ( drm_mode_get_encoder )
               ));
    assert_eq! (::std::mem::align_of::<drm_mode_get_encoder>() , 4usize ,
                concat ! (
                "Alignment of " , stringify ! ( drm_mode_get_encoder ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const drm_mode_get_encoder ) ) . encoder_id as
                * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( drm_mode_get_encoder )
                , "::" , stringify ! ( encoder_id ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const drm_mode_get_encoder ) ) . encoder_type
                as * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( drm_mode_get_encoder )
                , "::" , stringify ! ( encoder_type ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const drm_mode_get_encoder ) ) . crtc_id as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( drm_mode_get_encoder )
                , "::" , stringify ! ( crtc_id ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const drm_mode_get_encoder ) ) . possible_crtcs
                as * const _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( drm_mode_get_encoder )
                , "::" , stringify ! ( possible_crtcs ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const drm_mode_get_encoder ) ) .
                possible_clones as * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( drm_mode_get_encoder )
                , "::" , stringify ! ( possible_clones ) ));
}
impl Clone for drm_mode_get_encoder {
    fn clone(&self) -> Self { *self }
}
pub const drm_mode_subconnector_DRM_MODE_SUBCONNECTOR_Unknown:
          drm_mode_subconnector =
    drm_mode_subconnector::DRM_MODE_SUBCONNECTOR_Automatic;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum drm_mode_subconnector {
    DRM_MODE_SUBCONNECTOR_Automatic = 0,
    DRM_MODE_SUBCONNECTOR_DVID = 3,
    DRM_MODE_SUBCONNECTOR_DVIA = 4,
    DRM_MODE_SUBCONNECTOR_Composite = 5,
    DRM_MODE_SUBCONNECTOR_SVIDEO = 6,
    DRM_MODE_SUBCONNECTOR_Component = 8,
    DRM_MODE_SUBCONNECTOR_SCART = 9,
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct drm_mode_get_connector {
    pub encoders_ptr: __u64,
    pub modes_ptr: __u64,
    pub props_ptr: __u64,
    pub prop_values_ptr: __u64,
    pub count_modes: __u32,
    pub count_props: __u32,
    pub count_encoders: __u32,
    pub encoder_id: __u32,
    pub connector_id: __u32,
    pub connector_type: __u32,
    pub connector_type_id: __u32,
    pub connection: __u32,
    pub mm_width: __u32,
    pub mm_height: __u32,
    pub subpixel: __u32,
    pub pad: __u32,
}
#[test]
fn bindgen_test_layout_drm_mode_get_connector() {
    assert_eq!(::std::mem::size_of::<drm_mode_get_connector>() , 80usize ,
               concat ! ( "Size of: " , stringify ! ( drm_mode_get_connector )
               ));
    assert_eq! (::std::mem::align_of::<drm_mode_get_connector>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( drm_mode_get_connector ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const drm_mode_get_connector ) ) . encoders_ptr
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( drm_mode_get_connector
                ) , "::" , stringify ! ( encoders_ptr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const drm_mode_get_connector ) ) . modes_ptr as
                * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( drm_mode_get_connector
                ) , "::" , stringify ! ( modes_ptr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const drm_mode_get_connector ) ) . props_ptr as
                * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( drm_mode_get_connector
                ) , "::" , stringify ! ( props_ptr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const drm_mode_get_connector ) ) .
                prop_values_ptr as * const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( drm_mode_get_connector
                ) , "::" , stringify ! ( prop_values_ptr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const drm_mode_get_connector ) ) . count_modes
                as * const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( drm_mode_get_connector
                ) , "::" , stringify ! ( count_modes ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const drm_mode_get_connector ) ) . count_props
                as * const _ as usize } , 36usize , concat ! (
                "Alignment of field: " , stringify ! ( drm_mode_get_connector
                ) , "::" , stringify ! ( count_props ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const drm_mode_get_connector ) ) .
                count_encoders as * const _ as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( drm_mode_get_connector
                ) , "::" , stringify ! ( count_encoders ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const drm_mode_get_connector ) ) . encoder_id
                as * const _ as usize } , 44usize , concat ! (
                "Alignment of field: " , stringify ! ( drm_mode_get_connector
                ) , "::" , stringify ! ( encoder_id ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const drm_mode_get_connector ) ) . connector_id
                as * const _ as usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( drm_mode_get_connector
                ) , "::" , stringify ! ( connector_id ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const drm_mode_get_connector ) ) .
                connector_type as * const _ as usize } , 52usize , concat ! (
                "Alignment of field: " , stringify ! ( drm_mode_get_connector
                ) , "::" , stringify ! ( connector_type ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const drm_mode_get_connector ) ) .
                connector_type_id as * const _ as usize } , 56usize , concat !
                (
                "Alignment of field: " , stringify ! ( drm_mode_get_connector
                ) , "::" , stringify ! ( connector_type_id ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const drm_mode_get_connector ) ) . connection
                as * const _ as usize } , 60usize , concat ! (
                "Alignment of field: " , stringify ! ( drm_mode_get_connector
                ) , "::" , stringify ! ( connection ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const drm_mode_get_connector ) ) . mm_width as
                * const _ as usize } , 64usize , concat ! (
                "Alignment of field: " , stringify ! ( drm_mode_get_connector
                ) , "::" , stringify ! ( mm_width ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const drm_mode_get_connector ) ) . mm_height as
                * const _ as usize } , 68usize , concat ! (
                "Alignment of field: " , stringify ! ( drm_mode_get_connector
                ) , "::" , stringify ! ( mm_height ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const drm_mode_get_connector ) ) . subpixel as
                * const _ as usize } , 72usize , concat ! (
                "Alignment of field: " , stringify ! ( drm_mode_get_connector
                ) , "::" , stringify ! ( subpixel ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const drm_mode_get_connector ) ) . pad as *
                const _ as usize } , 76usize , concat ! (
                "Alignment of field: " , stringify ! ( drm_mode_get_connector
                ) , "::" , stringify ! ( pad ) ));
}
impl Clone for drm_mode_get_connector {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct drm_mode_property_enum {
    pub value: __u64,
    pub name: [libc::c_char; 32usize],
}
#[test]
fn bindgen_test_layout_drm_mode_property_enum() {
    assert_eq!(::std::mem::size_of::<drm_mode_property_enum>() , 40usize ,
               concat ! ( "Size of: " , stringify ! ( drm_mode_property_enum )
               ));
    assert_eq! (::std::mem::align_of::<drm_mode_property_enum>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( drm_mode_property_enum ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const drm_mode_property_enum ) ) . value as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( drm_mode_property_enum
                ) , "::" , stringify ! ( value ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const drm_mode_property_enum ) ) . name as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( drm_mode_property_enum
                ) , "::" , stringify ! ( name ) ));
}
impl Clone for drm_mode_property_enum {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct drm_mode_get_property {
    pub values_ptr: __u64,
    pub enum_blob_ptr: __u64,
    pub prop_id: __u32,
    pub flags: __u32,
    pub name: [libc::c_char; 32usize],
    pub count_values: __u32,
    pub count_enum_blobs: __u32,
}
#[test]
fn bindgen_test_layout_drm_mode_get_property() {
    assert_eq!(::std::mem::size_of::<drm_mode_get_property>() , 64usize ,
               concat ! ( "Size of: " , stringify ! ( drm_mode_get_property )
               ));
    assert_eq! (::std::mem::align_of::<drm_mode_get_property>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( drm_mode_get_property ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const drm_mode_get_property ) ) . values_ptr as
                * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( drm_mode_get_property )
                , "::" , stringify ! ( values_ptr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const drm_mode_get_property ) ) . enum_blob_ptr
                as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( drm_mode_get_property )
                , "::" , stringify ! ( enum_blob_ptr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const drm_mode_get_property ) ) . prop_id as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( drm_mode_get_property )
                , "::" , stringify ! ( prop_id ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const drm_mode_get_property ) ) . flags as *
                const _ as usize } , 20usize , concat ! (
                "Alignment of field: " , stringify ! ( drm_mode_get_property )
                , "::" , stringify ! ( flags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const drm_mode_get_property ) ) . name as *
                const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( drm_mode_get_property )
                , "::" , stringify ! ( name ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const drm_mode_get_property ) ) . count_values
                as * const _ as usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( drm_mode_get_property )
                , "::" , stringify ! ( count_values ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const drm_mode_get_property ) ) .
                count_enum_blobs as * const _ as usize } , 60usize , concat !
                (
                "Alignment of field: " , stringify ! ( drm_mode_get_property )
                , "::" , stringify ! ( count_enum_blobs ) ));
}
impl Clone for drm_mode_get_property {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct drm_mode_connector_set_property {
    pub value: __u64,
    pub prop_id: __u32,
    pub connector_id: __u32,
}
#[test]
fn bindgen_test_layout_drm_mode_connector_set_property() {
    assert_eq!(::std::mem::size_of::<drm_mode_connector_set_property>() ,
               16usize , concat ! (
               "Size of: " , stringify ! ( drm_mode_connector_set_property )
               ));
    assert_eq! (::std::mem::align_of::<drm_mode_connector_set_property>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! (
                drm_mode_connector_set_property ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const drm_mode_connector_set_property ) ) .
                value as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                drm_mode_connector_set_property ) , "::" , stringify ! ( value
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const drm_mode_connector_set_property ) ) .
                prop_id as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                drm_mode_connector_set_property ) , "::" , stringify ! (
                prop_id ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const drm_mode_connector_set_property ) ) .
                connector_id as * const _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! (
                drm_mode_connector_set_property ) , "::" , stringify ! (
                connector_id ) ));
}
impl Clone for drm_mode_connector_set_property {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct drm_mode_obj_get_properties {
    pub props_ptr: __u64,
    pub prop_values_ptr: __u64,
    pub count_props: __u32,
    pub obj_id: __u32,
    pub obj_type: __u32,
}
#[test]
fn bindgen_test_layout_drm_mode_obj_get_properties() {
    assert_eq!(::std::mem::size_of::<drm_mode_obj_get_properties>() , 32usize
               , concat ! (
               "Size of: " , stringify ! ( drm_mode_obj_get_properties ) ));
    assert_eq! (::std::mem::align_of::<drm_mode_obj_get_properties>() , 8usize
                , concat ! (
                "Alignment of " , stringify ! ( drm_mode_obj_get_properties )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const drm_mode_obj_get_properties ) ) .
                props_ptr as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                drm_mode_obj_get_properties ) , "::" , stringify ! ( props_ptr
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const drm_mode_obj_get_properties ) ) .
                prop_values_ptr as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                drm_mode_obj_get_properties ) , "::" , stringify ! (
                prop_values_ptr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const drm_mode_obj_get_properties ) ) .
                count_props as * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! (
                drm_mode_obj_get_properties ) , "::" , stringify ! (
                count_props ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const drm_mode_obj_get_properties ) ) . obj_id
                as * const _ as usize } , 20usize , concat ! (
                "Alignment of field: " , stringify ! (
                drm_mode_obj_get_properties ) , "::" , stringify ! ( obj_id )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const drm_mode_obj_get_properties ) ) .
                obj_type as * const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! (
                drm_mode_obj_get_properties ) , "::" , stringify ! ( obj_type
                ) ));
}
impl Clone for drm_mode_obj_get_properties {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct drm_mode_obj_set_property {
    pub value: __u64,
    pub prop_id: __u32,
    pub obj_id: __u32,
    pub obj_type: __u32,
}
#[test]
fn bindgen_test_layout_drm_mode_obj_set_property() {
    assert_eq!(::std::mem::size_of::<drm_mode_obj_set_property>() , 24usize ,
               concat ! (
               "Size of: " , stringify ! ( drm_mode_obj_set_property ) ));
    assert_eq! (::std::mem::align_of::<drm_mode_obj_set_property>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( drm_mode_obj_set_property )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const drm_mode_obj_set_property ) ) . value as
                * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                drm_mode_obj_set_property ) , "::" , stringify ! ( value ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const drm_mode_obj_set_property ) ) . prop_id
                as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                drm_mode_obj_set_property ) , "::" , stringify ! ( prop_id )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const drm_mode_obj_set_property ) ) . obj_id as
                * const _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! (
                drm_mode_obj_set_property ) , "::" , stringify ! ( obj_id )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const drm_mode_obj_set_property ) ) . obj_type
                as * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! (
                drm_mode_obj_set_property ) , "::" , stringify ! ( obj_type )
                ));
}
impl Clone for drm_mode_obj_set_property {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct drm_mode_get_blob {
    pub blob_id: __u32,
    pub length: __u32,
    pub data: __u64,
}
#[test]
fn bindgen_test_layout_drm_mode_get_blob() {
    assert_eq!(::std::mem::size_of::<drm_mode_get_blob>() , 16usize , concat !
               ( "Size of: " , stringify ! ( drm_mode_get_blob ) ));
    assert_eq! (::std::mem::align_of::<drm_mode_get_blob>() , 8usize , concat
                ! ( "Alignment of " , stringify ! ( drm_mode_get_blob ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const drm_mode_get_blob ) ) . blob_id as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( drm_mode_get_blob ) ,
                "::" , stringify ! ( blob_id ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const drm_mode_get_blob ) ) . length as * const
                _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( drm_mode_get_blob ) ,
                "::" , stringify ! ( length ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const drm_mode_get_blob ) ) . data as * const _
                as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( drm_mode_get_blob ) ,
                "::" , stringify ! ( data ) ));
}
impl Clone for drm_mode_get_blob {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct drm_mode_fb_cmd {
    pub fb_id: __u32,
    pub width: __u32,
    pub height: __u32,
    pub pitch: __u32,
    pub bpp: __u32,
    pub depth: __u32,
    pub handle: __u32,
}
#[test]
fn bindgen_test_layout_drm_mode_fb_cmd() {
    assert_eq!(::std::mem::size_of::<drm_mode_fb_cmd>() , 28usize , concat ! (
               "Size of: " , stringify ! ( drm_mode_fb_cmd ) ));
    assert_eq! (::std::mem::align_of::<drm_mode_fb_cmd>() , 4usize , concat !
                ( "Alignment of " , stringify ! ( drm_mode_fb_cmd ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const drm_mode_fb_cmd ) ) . fb_id as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( drm_mode_fb_cmd ) ,
                "::" , stringify ! ( fb_id ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const drm_mode_fb_cmd ) ) . width as * const _
                as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( drm_mode_fb_cmd ) ,
                "::" , stringify ! ( width ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const drm_mode_fb_cmd ) ) . height as * const _
                as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( drm_mode_fb_cmd ) ,
                "::" , stringify ! ( height ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const drm_mode_fb_cmd ) ) . pitch as * const _
                as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( drm_mode_fb_cmd ) ,
                "::" , stringify ! ( pitch ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const drm_mode_fb_cmd ) ) . bpp as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( drm_mode_fb_cmd ) ,
                "::" , stringify ! ( bpp ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const drm_mode_fb_cmd ) ) . depth as * const _
                as usize } , 20usize , concat ! (
                "Alignment of field: " , stringify ! ( drm_mode_fb_cmd ) ,
                "::" , stringify ! ( depth ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const drm_mode_fb_cmd ) ) . handle as * const _
                as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( drm_mode_fb_cmd ) ,
                "::" , stringify ! ( handle ) ));
}
impl Clone for drm_mode_fb_cmd {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct drm_mode_fb_cmd2 {
    pub fb_id: __u32,
    pub width: __u32,
    pub height: __u32,
    pub pixel_format: __u32,
    pub flags: __u32,
    pub handles: [__u32; 4usize],
    pub pitches: [__u32; 4usize],
    pub offsets: [__u32; 4usize],
    pub modifier: [__u64; 4usize],
}
#[test]
fn bindgen_test_layout_drm_mode_fb_cmd2() {
    assert_eq!(::std::mem::size_of::<drm_mode_fb_cmd2>() , 104usize , concat !
               ( "Size of: " , stringify ! ( drm_mode_fb_cmd2 ) ));
    assert_eq! (::std::mem::align_of::<drm_mode_fb_cmd2>() , 8usize , concat !
                ( "Alignment of " , stringify ! ( drm_mode_fb_cmd2 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const drm_mode_fb_cmd2 ) ) . fb_id as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( drm_mode_fb_cmd2 ) ,
                "::" , stringify ! ( fb_id ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const drm_mode_fb_cmd2 ) ) . width as * const _
                as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( drm_mode_fb_cmd2 ) ,
                "::" , stringify ! ( width ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const drm_mode_fb_cmd2 ) ) . height as * const
                _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( drm_mode_fb_cmd2 ) ,
                "::" , stringify ! ( height ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const drm_mode_fb_cmd2 ) ) . pixel_format as *
                const _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( drm_mode_fb_cmd2 ) ,
                "::" , stringify ! ( pixel_format ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const drm_mode_fb_cmd2 ) ) . flags as * const _
                as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( drm_mode_fb_cmd2 ) ,
                "::" , stringify ! ( flags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const drm_mode_fb_cmd2 ) ) . handles as * const
                _ as usize } , 20usize , concat ! (
                "Alignment of field: " , stringify ! ( drm_mode_fb_cmd2 ) ,
                "::" , stringify ! ( handles ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const drm_mode_fb_cmd2 ) ) . pitches as * const
                _ as usize } , 36usize , concat ! (
                "Alignment of field: " , stringify ! ( drm_mode_fb_cmd2 ) ,
                "::" , stringify ! ( pitches ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const drm_mode_fb_cmd2 ) ) . offsets as * const
                _ as usize } , 52usize , concat ! (
                "Alignment of field: " , stringify ! ( drm_mode_fb_cmd2 ) ,
                "::" , stringify ! ( offsets ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const drm_mode_fb_cmd2 ) ) . modifier as *
                const _ as usize } , 72usize , concat ! (
                "Alignment of field: " , stringify ! ( drm_mode_fb_cmd2 ) ,
                "::" , stringify ! ( modifier ) ));
}
impl Clone for drm_mode_fb_cmd2 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct drm_mode_fb_dirty_cmd {
    pub fb_id: __u32,
    pub flags: __u32,
    pub color: __u32,
    pub num_clips: __u32,
    pub clips_ptr: __u64,
}
#[test]
fn bindgen_test_layout_drm_mode_fb_dirty_cmd() {
    assert_eq!(::std::mem::size_of::<drm_mode_fb_dirty_cmd>() , 24usize ,
               concat ! ( "Size of: " , stringify ! ( drm_mode_fb_dirty_cmd )
               ));
    assert_eq! (::std::mem::align_of::<drm_mode_fb_dirty_cmd>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( drm_mode_fb_dirty_cmd ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const drm_mode_fb_dirty_cmd ) ) . fb_id as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( drm_mode_fb_dirty_cmd )
                , "::" , stringify ! ( fb_id ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const drm_mode_fb_dirty_cmd ) ) . flags as *
                const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( drm_mode_fb_dirty_cmd )
                , "::" , stringify ! ( flags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const drm_mode_fb_dirty_cmd ) ) . color as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( drm_mode_fb_dirty_cmd )
                , "::" , stringify ! ( color ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const drm_mode_fb_dirty_cmd ) ) . num_clips as
                * const _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( drm_mode_fb_dirty_cmd )
                , "::" , stringify ! ( num_clips ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const drm_mode_fb_dirty_cmd ) ) . clips_ptr as
                * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( drm_mode_fb_dirty_cmd )
                , "::" , stringify ! ( clips_ptr ) ));
}
impl Clone for drm_mode_fb_dirty_cmd {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct drm_mode_mode_cmd {
    pub connector_id: __u32,
    pub mode: drm_mode_modeinfo,
}
#[test]
fn bindgen_test_layout_drm_mode_mode_cmd() {
    assert_eq!(::std::mem::size_of::<drm_mode_mode_cmd>() , 72usize , concat !
               ( "Size of: " , stringify ! ( drm_mode_mode_cmd ) ));
    assert_eq! (::std::mem::align_of::<drm_mode_mode_cmd>() , 4usize , concat
                ! ( "Alignment of " , stringify ! ( drm_mode_mode_cmd ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const drm_mode_mode_cmd ) ) . connector_id as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( drm_mode_mode_cmd ) ,
                "::" , stringify ! ( connector_id ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const drm_mode_mode_cmd ) ) . mode as * const _
                as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( drm_mode_mode_cmd ) ,
                "::" , stringify ! ( mode ) ));
}
impl Clone for drm_mode_mode_cmd {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct drm_mode_cursor {
    pub flags: __u32,
    pub crtc_id: __u32,
    pub x: __s32,
    pub y: __s32,
    pub width: __u32,
    pub height: __u32,
    pub handle: __u32,
}
#[test]
fn bindgen_test_layout_drm_mode_cursor() {
    assert_eq!(::std::mem::size_of::<drm_mode_cursor>() , 28usize , concat ! (
               "Size of: " , stringify ! ( drm_mode_cursor ) ));
    assert_eq! (::std::mem::align_of::<drm_mode_cursor>() , 4usize , concat !
                ( "Alignment of " , stringify ! ( drm_mode_cursor ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const drm_mode_cursor ) ) . flags as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( drm_mode_cursor ) ,
                "::" , stringify ! ( flags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const drm_mode_cursor ) ) . crtc_id as * const
                _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( drm_mode_cursor ) ,
                "::" , stringify ! ( crtc_id ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const drm_mode_cursor ) ) . x as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( drm_mode_cursor ) ,
                "::" , stringify ! ( x ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const drm_mode_cursor ) ) . y as * const _ as
                usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( drm_mode_cursor ) ,
                "::" , stringify ! ( y ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const drm_mode_cursor ) ) . width as * const _
                as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( drm_mode_cursor ) ,
                "::" , stringify ! ( width ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const drm_mode_cursor ) ) . height as * const _
                as usize } , 20usize , concat ! (
                "Alignment of field: " , stringify ! ( drm_mode_cursor ) ,
                "::" , stringify ! ( height ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const drm_mode_cursor ) ) . handle as * const _
                as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( drm_mode_cursor ) ,
                "::" , stringify ! ( handle ) ));
}
impl Clone for drm_mode_cursor {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct drm_mode_cursor2 {
    pub flags: __u32,
    pub crtc_id: __u32,
    pub x: __s32,
    pub y: __s32,
    pub width: __u32,
    pub height: __u32,
    pub handle: __u32,
    pub hot_x: __s32,
    pub hot_y: __s32,
}
#[test]
fn bindgen_test_layout_drm_mode_cursor2() {
    assert_eq!(::std::mem::size_of::<drm_mode_cursor2>() , 36usize , concat !
               ( "Size of: " , stringify ! ( drm_mode_cursor2 ) ));
    assert_eq! (::std::mem::align_of::<drm_mode_cursor2>() , 4usize , concat !
                ( "Alignment of " , stringify ! ( drm_mode_cursor2 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const drm_mode_cursor2 ) ) . flags as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( drm_mode_cursor2 ) ,
                "::" , stringify ! ( flags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const drm_mode_cursor2 ) ) . crtc_id as * const
                _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( drm_mode_cursor2 ) ,
                "::" , stringify ! ( crtc_id ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const drm_mode_cursor2 ) ) . x as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( drm_mode_cursor2 ) ,
                "::" , stringify ! ( x ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const drm_mode_cursor2 ) ) . y as * const _ as
                usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( drm_mode_cursor2 ) ,
                "::" , stringify ! ( y ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const drm_mode_cursor2 ) ) . width as * const _
                as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( drm_mode_cursor2 ) ,
                "::" , stringify ! ( width ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const drm_mode_cursor2 ) ) . height as * const
                _ as usize } , 20usize , concat ! (
                "Alignment of field: " , stringify ! ( drm_mode_cursor2 ) ,
                "::" , stringify ! ( height ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const drm_mode_cursor2 ) ) . handle as * const
                _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( drm_mode_cursor2 ) ,
                "::" , stringify ! ( handle ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const drm_mode_cursor2 ) ) . hot_x as * const _
                as usize } , 28usize , concat ! (
                "Alignment of field: " , stringify ! ( drm_mode_cursor2 ) ,
                "::" , stringify ! ( hot_x ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const drm_mode_cursor2 ) ) . hot_y as * const _
                as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( drm_mode_cursor2 ) ,
                "::" , stringify ! ( hot_y ) ));
}
impl Clone for drm_mode_cursor2 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct drm_mode_crtc_lut {
    pub crtc_id: __u32,
    pub gamma_size: __u32,
    pub red: __u64,
    pub green: __u64,
    pub blue: __u64,
}
#[test]
fn bindgen_test_layout_drm_mode_crtc_lut() {
    assert_eq!(::std::mem::size_of::<drm_mode_crtc_lut>() , 32usize , concat !
               ( "Size of: " , stringify ! ( drm_mode_crtc_lut ) ));
    assert_eq! (::std::mem::align_of::<drm_mode_crtc_lut>() , 8usize , concat
                ! ( "Alignment of " , stringify ! ( drm_mode_crtc_lut ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const drm_mode_crtc_lut ) ) . crtc_id as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( drm_mode_crtc_lut ) ,
                "::" , stringify ! ( crtc_id ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const drm_mode_crtc_lut ) ) . gamma_size as *
                const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( drm_mode_crtc_lut ) ,
                "::" , stringify ! ( gamma_size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const drm_mode_crtc_lut ) ) . red as * const _
                as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( drm_mode_crtc_lut ) ,
                "::" , stringify ! ( red ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const drm_mode_crtc_lut ) ) . green as * const
                _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( drm_mode_crtc_lut ) ,
                "::" , stringify ! ( green ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const drm_mode_crtc_lut ) ) . blue as * const _
                as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( drm_mode_crtc_lut ) ,
                "::" , stringify ! ( blue ) ));
}
impl Clone for drm_mode_crtc_lut {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct drm_color_ctm {
    pub matrix: [__s64; 9usize],
}
#[test]
fn bindgen_test_layout_drm_color_ctm() {
    assert_eq!(::std::mem::size_of::<drm_color_ctm>() , 72usize , concat ! (
               "Size of: " , stringify ! ( drm_color_ctm ) ));
    assert_eq! (::std::mem::align_of::<drm_color_ctm>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( drm_color_ctm ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const drm_color_ctm ) ) . matrix as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( drm_color_ctm ) , "::"
                , stringify ! ( matrix ) ));
}
impl Clone for drm_color_ctm {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct drm_color_lut {
    pub red: __u16,
    pub green: __u16,
    pub blue: __u16,
    pub reserved: __u16,
}
#[test]
fn bindgen_test_layout_drm_color_lut() {
    assert_eq!(::std::mem::size_of::<drm_color_lut>() , 8usize , concat ! (
               "Size of: " , stringify ! ( drm_color_lut ) ));
    assert_eq! (::std::mem::align_of::<drm_color_lut>() , 2usize , concat ! (
                "Alignment of " , stringify ! ( drm_color_lut ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const drm_color_lut ) ) . red as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( drm_color_lut ) , "::"
                , stringify ! ( red ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const drm_color_lut ) ) . green as * const _ as
                usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! ( drm_color_lut ) , "::"
                , stringify ! ( green ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const drm_color_lut ) ) . blue as * const _ as
                usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( drm_color_lut ) , "::"
                , stringify ! ( blue ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const drm_color_lut ) ) . reserved as * const _
                as usize } , 6usize , concat ! (
                "Alignment of field: " , stringify ! ( drm_color_lut ) , "::"
                , stringify ! ( reserved ) ));
}
impl Clone for drm_color_lut {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct drm_mode_crtc_page_flip {
    pub crtc_id: __u32,
    pub fb_id: __u32,
    pub flags: __u32,
    pub reserved: __u32,
    pub user_data: __u64,
}
#[test]
fn bindgen_test_layout_drm_mode_crtc_page_flip() {
    assert_eq!(::std::mem::size_of::<drm_mode_crtc_page_flip>() , 24usize ,
               concat ! (
               "Size of: " , stringify ! ( drm_mode_crtc_page_flip ) ));
    assert_eq! (::std::mem::align_of::<drm_mode_crtc_page_flip>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( drm_mode_crtc_page_flip ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const drm_mode_crtc_page_flip ) ) . crtc_id as
                * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( drm_mode_crtc_page_flip
                ) , "::" , stringify ! ( crtc_id ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const drm_mode_crtc_page_flip ) ) . fb_id as *
                const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( drm_mode_crtc_page_flip
                ) , "::" , stringify ! ( fb_id ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const drm_mode_crtc_page_flip ) ) . flags as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( drm_mode_crtc_page_flip
                ) , "::" , stringify ! ( flags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const drm_mode_crtc_page_flip ) ) . reserved as
                * const _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( drm_mode_crtc_page_flip
                ) , "::" , stringify ! ( reserved ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const drm_mode_crtc_page_flip ) ) . user_data
                as * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( drm_mode_crtc_page_flip
                ) , "::" , stringify ! ( user_data ) ));
}
impl Clone for drm_mode_crtc_page_flip {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct drm_mode_crtc_page_flip_target {
    pub crtc_id: __u32,
    pub fb_id: __u32,
    pub flags: __u32,
    pub sequence: __u32,
    pub user_data: __u64,
}
#[test]
fn bindgen_test_layout_drm_mode_crtc_page_flip_target() {
    assert_eq!(::std::mem::size_of::<drm_mode_crtc_page_flip_target>() ,
               24usize , concat ! (
               "Size of: " , stringify ! ( drm_mode_crtc_page_flip_target )
               ));
    assert_eq! (::std::mem::align_of::<drm_mode_crtc_page_flip_target>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! ( drm_mode_crtc_page_flip_target
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const drm_mode_crtc_page_flip_target ) ) .
                crtc_id as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                drm_mode_crtc_page_flip_target ) , "::" , stringify ! (
                crtc_id ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const drm_mode_crtc_page_flip_target ) ) .
                fb_id as * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! (
                drm_mode_crtc_page_flip_target ) , "::" , stringify ! ( fb_id
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const drm_mode_crtc_page_flip_target ) ) .
                flags as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                drm_mode_crtc_page_flip_target ) , "::" , stringify ! ( flags
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const drm_mode_crtc_page_flip_target ) ) .
                sequence as * const _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! (
                drm_mode_crtc_page_flip_target ) , "::" , stringify ! (
                sequence ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const drm_mode_crtc_page_flip_target ) ) .
                user_data as * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! (
                drm_mode_crtc_page_flip_target ) , "::" , stringify ! (
                user_data ) ));
}
impl Clone for drm_mode_crtc_page_flip_target {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct drm_mode_create_dumb {
    pub height: __u32,
    pub width: __u32,
    pub bpp: __u32,
    pub flags: __u32,
    pub handle: __u32,
    pub pitch: __u32,
    pub size: __u64,
}
#[test]
fn bindgen_test_layout_drm_mode_create_dumb() {
    assert_eq!(::std::mem::size_of::<drm_mode_create_dumb>() , 32usize ,
               concat ! ( "Size of: " , stringify ! ( drm_mode_create_dumb )
               ));
    assert_eq! (::std::mem::align_of::<drm_mode_create_dumb>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( drm_mode_create_dumb ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const drm_mode_create_dumb ) ) . height as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( drm_mode_create_dumb )
                , "::" , stringify ! ( height ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const drm_mode_create_dumb ) ) . width as *
                const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( drm_mode_create_dumb )
                , "::" , stringify ! ( width ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const drm_mode_create_dumb ) ) . bpp as * const
                _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( drm_mode_create_dumb )
                , "::" , stringify ! ( bpp ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const drm_mode_create_dumb ) ) . flags as *
                const _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( drm_mode_create_dumb )
                , "::" , stringify ! ( flags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const drm_mode_create_dumb ) ) . handle as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( drm_mode_create_dumb )
                , "::" , stringify ! ( handle ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const drm_mode_create_dumb ) ) . pitch as *
                const _ as usize } , 20usize , concat ! (
                "Alignment of field: " , stringify ! ( drm_mode_create_dumb )
                , "::" , stringify ! ( pitch ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const drm_mode_create_dumb ) ) . size as *
                const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( drm_mode_create_dumb )
                , "::" , stringify ! ( size ) ));
}
impl Clone for drm_mode_create_dumb {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct drm_mode_map_dumb {
    pub handle: __u32,
    pub pad: __u32,
    pub offset: __u64,
}
#[test]
fn bindgen_test_layout_drm_mode_map_dumb() {
    assert_eq!(::std::mem::size_of::<drm_mode_map_dumb>() , 16usize , concat !
               ( "Size of: " , stringify ! ( drm_mode_map_dumb ) ));
    assert_eq! (::std::mem::align_of::<drm_mode_map_dumb>() , 8usize , concat
                ! ( "Alignment of " , stringify ! ( drm_mode_map_dumb ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const drm_mode_map_dumb ) ) . handle as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( drm_mode_map_dumb ) ,
                "::" , stringify ! ( handle ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const drm_mode_map_dumb ) ) . pad as * const _
                as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( drm_mode_map_dumb ) ,
                "::" , stringify ! ( pad ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const drm_mode_map_dumb ) ) . offset as * const
                _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( drm_mode_map_dumb ) ,
                "::" , stringify ! ( offset ) ));
}
impl Clone for drm_mode_map_dumb {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct drm_mode_destroy_dumb {
    pub handle: __u32,
}
#[test]
fn bindgen_test_layout_drm_mode_destroy_dumb() {
    assert_eq!(::std::mem::size_of::<drm_mode_destroy_dumb>() , 4usize ,
               concat ! ( "Size of: " , stringify ! ( drm_mode_destroy_dumb )
               ));
    assert_eq! (::std::mem::align_of::<drm_mode_destroy_dumb>() , 4usize ,
                concat ! (
                "Alignment of " , stringify ! ( drm_mode_destroy_dumb ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const drm_mode_destroy_dumb ) ) . handle as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( drm_mode_destroy_dumb )
                , "::" , stringify ! ( handle ) ));
}
impl Clone for drm_mode_destroy_dumb {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct drm_mode_atomic {
    pub flags: __u32,
    pub count_objs: __u32,
    pub objs_ptr: __u64,
    pub count_props_ptr: __u64,
    pub props_ptr: __u64,
    pub prop_values_ptr: __u64,
    pub reserved: __u64,
    pub user_data: __u64,
}
#[test]
fn bindgen_test_layout_drm_mode_atomic() {
    assert_eq!(::std::mem::size_of::<drm_mode_atomic>() , 56usize , concat ! (
               "Size of: " , stringify ! ( drm_mode_atomic ) ));
    assert_eq! (::std::mem::align_of::<drm_mode_atomic>() , 8usize , concat !
                ( "Alignment of " , stringify ! ( drm_mode_atomic ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const drm_mode_atomic ) ) . flags as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( drm_mode_atomic ) ,
                "::" , stringify ! ( flags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const drm_mode_atomic ) ) . count_objs as *
                const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( drm_mode_atomic ) ,
                "::" , stringify ! ( count_objs ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const drm_mode_atomic ) ) . objs_ptr as * const
                _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( drm_mode_atomic ) ,
                "::" , stringify ! ( objs_ptr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const drm_mode_atomic ) ) . count_props_ptr as
                * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( drm_mode_atomic ) ,
                "::" , stringify ! ( count_props_ptr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const drm_mode_atomic ) ) . props_ptr as *
                const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( drm_mode_atomic ) ,
                "::" , stringify ! ( props_ptr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const drm_mode_atomic ) ) . prop_values_ptr as
                * const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( drm_mode_atomic ) ,
                "::" , stringify ! ( prop_values_ptr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const drm_mode_atomic ) ) . reserved as * const
                _ as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( drm_mode_atomic ) ,
                "::" , stringify ! ( reserved ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const drm_mode_atomic ) ) . user_data as *
                const _ as usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( drm_mode_atomic ) ,
                "::" , stringify ! ( user_data ) ));
}
impl Clone for drm_mode_atomic {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct drm_mode_create_blob {
    pub data: __u64,
    pub length: __u32,
    pub blob_id: __u32,
}
#[test]
fn bindgen_test_layout_drm_mode_create_blob() {
    assert_eq!(::std::mem::size_of::<drm_mode_create_blob>() , 16usize ,
               concat ! ( "Size of: " , stringify ! ( drm_mode_create_blob )
               ));
    assert_eq! (::std::mem::align_of::<drm_mode_create_blob>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( drm_mode_create_blob ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const drm_mode_create_blob ) ) . data as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( drm_mode_create_blob )
                , "::" , stringify ! ( data ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const drm_mode_create_blob ) ) . length as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( drm_mode_create_blob )
                , "::" , stringify ! ( length ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const drm_mode_create_blob ) ) . blob_id as *
                const _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( drm_mode_create_blob )
                , "::" , stringify ! ( blob_id ) ));
}
impl Clone for drm_mode_create_blob {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct drm_mode_destroy_blob {
    pub blob_id: __u32,
}
#[test]
fn bindgen_test_layout_drm_mode_destroy_blob() {
    assert_eq!(::std::mem::size_of::<drm_mode_destroy_blob>() , 4usize ,
               concat ! ( "Size of: " , stringify ! ( drm_mode_destroy_blob )
               ));
    assert_eq! (::std::mem::align_of::<drm_mode_destroy_blob>() , 4usize ,
                concat ! (
                "Alignment of " , stringify ! ( drm_mode_destroy_blob ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const drm_mode_destroy_blob ) ) . blob_id as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( drm_mode_destroy_blob )
                , "::" , stringify ! ( blob_id ) ));
}
impl Clone for drm_mode_destroy_blob {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct drm_event {
    pub type_: __u32,
    pub length: __u32,
}
#[test]
fn bindgen_test_layout_drm_event() {
    assert_eq!(::std::mem::size_of::<drm_event>() , 8usize , concat ! (
               "Size of: " , stringify ! ( drm_event ) ));
    assert_eq! (::std::mem::align_of::<drm_event>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( drm_event ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const drm_event ) ) . type_ as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( drm_event ) , "::" ,
                stringify ! ( type_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const drm_event ) ) . length as * const _ as
                usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( drm_event ) , "::" ,
                stringify ! ( length ) ));
}
impl Clone for drm_event {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct drm_event_vblank {
    pub base: drm_event,
    pub user_data: __u64,
    pub tv_sec: __u32,
    pub tv_usec: __u32,
    pub sequence: __u32,
    pub reserved: __u32,
}
#[test]
fn bindgen_test_layout_drm_event_vblank() {
    assert_eq!(::std::mem::size_of::<drm_event_vblank>() , 32usize , concat !
               ( "Size of: " , stringify ! ( drm_event_vblank ) ));
    assert_eq! (::std::mem::align_of::<drm_event_vblank>() , 8usize , concat !
                ( "Alignment of " , stringify ! ( drm_event_vblank ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const drm_event_vblank ) ) . base as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( drm_event_vblank ) ,
                "::" , stringify ! ( base ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const drm_event_vblank ) ) . user_data as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( drm_event_vblank ) ,
                "::" , stringify ! ( user_data ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const drm_event_vblank ) ) . tv_sec as * const
                _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( drm_event_vblank ) ,
                "::" , stringify ! ( tv_sec ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const drm_event_vblank ) ) . tv_usec as * const
                _ as usize } , 20usize , concat ! (
                "Alignment of field: " , stringify ! ( drm_event_vblank ) ,
                "::" , stringify ! ( tv_usec ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const drm_event_vblank ) ) . sequence as *
                const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( drm_event_vblank ) ,
                "::" , stringify ! ( sequence ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const drm_event_vblank ) ) . reserved as *
                const _ as usize } , 28usize , concat ! (
                "Alignment of field: " , stringify ! ( drm_event_vblank ) ,
                "::" , stringify ! ( reserved ) ));
}
impl Clone for drm_event_vblank {
    fn clone(&self) -> Self { *self }
}
pub type drm_clip_rect_t = drm_clip_rect;
pub type drm_drawable_info_t = drm_drawable_info;
pub type drm_tex_region_t = drm_tex_region;
pub type drm_hw_lock_t = drm_hw_lock;
pub type drm_version_t = drm_version;
pub type drm_unique_t = drm_unique;
pub type drm_list_t = drm_list;
pub type drm_block_t = drm_block;
pub type drm_control_t = drm_control;
pub use self::drm_map_type as drm_map_type_t;
pub use self::drm_map_flags as drm_map_flags_t;
pub type drm_ctx_priv_map_t = drm_ctx_priv_map;
pub type drm_map_t = drm_map;
pub type drm_client_t = drm_client;
pub use self::drm_stat_type as drm_stat_type_t;
pub type drm_stats_t = drm_stats;
pub use self::drm_lock_flags as drm_lock_flags_t;
pub type drm_lock_t = drm_lock;
pub use self::drm_dma_flags as drm_dma_flags_t;
pub type drm_buf_desc_t = drm_buf_desc;
pub type drm_buf_info_t = drm_buf_info;
pub type drm_buf_free_t = drm_buf_free;
pub type drm_buf_pub_t = drm_buf_pub;
pub type drm_buf_map_t = drm_buf_map;
pub type drm_dma_t = drm_dma;
pub type drm_wait_vblank_t = drm_wait_vblank;
pub type drm_agp_mode_t = drm_agp_mode;
pub use self::drm_ctx_flags as drm_ctx_flags_t;
pub type drm_ctx_t = drm_ctx;
pub type drm_ctx_res_t = drm_ctx_res;
pub type drm_draw_t = drm_draw;
pub type drm_update_draw_t = drm_update_draw;
pub type drm_auth_t = drm_auth;
pub type drm_irq_busid_t = drm_irq_busid;
pub use self::drm_vblank_seq_type as drm_vblank_seq_type_t;
pub type drm_agp_buffer_t = drm_agp_buffer;
pub type drm_agp_binding_t = drm_agp_binding;
pub type drm_agp_info_t = drm_agp_info;
pub type drm_scatter_gather_t = drm_scatter_gather;
pub type drm_set_version_t = drm_set_version;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _drmModeRes {
    pub count_fbs: libc::c_int,
    pub fbs: *mut u32,
    pub count_crtcs: libc::c_int,
    pub crtcs: *mut u32,
    pub count_connectors: libc::c_int,
    pub connectors: *mut u32,
    pub count_encoders: libc::c_int,
    pub encoders: *mut u32,
    pub min_width: u32,
    pub max_width: u32,
    pub min_height: u32,
    pub max_height: u32,
}
#[test]
fn bindgen_test_layout__drmModeRes() {
    assert_eq!(::std::mem::size_of::<_drmModeRes>() , 80usize , concat ! (
               "Size of: " , stringify ! ( _drmModeRes ) ));
    assert_eq! (::std::mem::align_of::<_drmModeRes>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( _drmModeRes ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _drmModeRes ) ) . count_fbs as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _drmModeRes ) , "::" ,
                stringify ! ( count_fbs ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _drmModeRes ) ) . fbs as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( _drmModeRes ) , "::" ,
                stringify ! ( fbs ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _drmModeRes ) ) . count_crtcs as * const
                _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( _drmModeRes ) , "::" ,
                stringify ! ( count_crtcs ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _drmModeRes ) ) . crtcs as * const _ as
                usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( _drmModeRes ) , "::" ,
                stringify ! ( crtcs ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _drmModeRes ) ) . count_connectors as *
                const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( _drmModeRes ) , "::" ,
                stringify ! ( count_connectors ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _drmModeRes ) ) . connectors as * const _
                as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( _drmModeRes ) , "::" ,
                stringify ! ( connectors ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _drmModeRes ) ) . count_encoders as *
                const _ as usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( _drmModeRes ) , "::" ,
                stringify ! ( count_encoders ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _drmModeRes ) ) . encoders as * const _
                as usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( _drmModeRes ) , "::" ,
                stringify ! ( encoders ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _drmModeRes ) ) . min_width as * const _
                as usize } , 64usize , concat ! (
                "Alignment of field: " , stringify ! ( _drmModeRes ) , "::" ,
                stringify ! ( min_width ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _drmModeRes ) ) . max_width as * const _
                as usize } , 68usize , concat ! (
                "Alignment of field: " , stringify ! ( _drmModeRes ) , "::" ,
                stringify ! ( max_width ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _drmModeRes ) ) . min_height as * const _
                as usize } , 72usize , concat ! (
                "Alignment of field: " , stringify ! ( _drmModeRes ) , "::" ,
                stringify ! ( min_height ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _drmModeRes ) ) . max_height as * const _
                as usize } , 76usize , concat ! (
                "Alignment of field: " , stringify ! ( _drmModeRes ) , "::" ,
                stringify ! ( max_height ) ));
}
impl Clone for _drmModeRes {
    fn clone(&self) -> Self { *self }
}
impl Default for _drmModeRes {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type drmModeRes = _drmModeRes;
pub type drmModeResPtr = *mut _drmModeRes;
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct _drmModeModeInfo {
    pub clock: u32,
    pub hdisplay: u16,
    pub hsync_start: u16,
    pub hsync_end: u16,
    pub htotal: u16,
    pub hskew: u16,
    pub vdisplay: u16,
    pub vsync_start: u16,
    pub vsync_end: u16,
    pub vtotal: u16,
    pub vscan: u16,
    pub vrefresh: u32,
    pub flags: u32,
    pub type_: u32,
    pub name: [libc::c_char; 32usize],
}
#[test]
fn bindgen_test_layout__drmModeModeInfo() {
    assert_eq!(::std::mem::size_of::<_drmModeModeInfo>() , 68usize , concat !
               ( "Size of: " , stringify ! ( _drmModeModeInfo ) ));
    assert_eq! (::std::mem::align_of::<_drmModeModeInfo>() , 4usize , concat !
                ( "Alignment of " , stringify ! ( _drmModeModeInfo ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _drmModeModeInfo ) ) . clock as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _drmModeModeInfo ) ,
                "::" , stringify ! ( clock ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _drmModeModeInfo ) ) . hdisplay as *
                const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( _drmModeModeInfo ) ,
                "::" , stringify ! ( hdisplay ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _drmModeModeInfo ) ) . hsync_start as *
                const _ as usize } , 6usize , concat ! (
                "Alignment of field: " , stringify ! ( _drmModeModeInfo ) ,
                "::" , stringify ! ( hsync_start ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _drmModeModeInfo ) ) . hsync_end as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( _drmModeModeInfo ) ,
                "::" , stringify ! ( hsync_end ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _drmModeModeInfo ) ) . htotal as * const
                _ as usize } , 10usize , concat ! (
                "Alignment of field: " , stringify ! ( _drmModeModeInfo ) ,
                "::" , stringify ! ( htotal ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _drmModeModeInfo ) ) . hskew as * const _
                as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( _drmModeModeInfo ) ,
                "::" , stringify ! ( hskew ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _drmModeModeInfo ) ) . vdisplay as *
                const _ as usize } , 14usize , concat ! (
                "Alignment of field: " , stringify ! ( _drmModeModeInfo ) ,
                "::" , stringify ! ( vdisplay ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _drmModeModeInfo ) ) . vsync_start as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( _drmModeModeInfo ) ,
                "::" , stringify ! ( vsync_start ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _drmModeModeInfo ) ) . vsync_end as *
                const _ as usize } , 18usize , concat ! (
                "Alignment of field: " , stringify ! ( _drmModeModeInfo ) ,
                "::" , stringify ! ( vsync_end ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _drmModeModeInfo ) ) . vtotal as * const
                _ as usize } , 20usize , concat ! (
                "Alignment of field: " , stringify ! ( _drmModeModeInfo ) ,
                "::" , stringify ! ( vtotal ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _drmModeModeInfo ) ) . vscan as * const _
                as usize } , 22usize , concat ! (
                "Alignment of field: " , stringify ! ( _drmModeModeInfo ) ,
                "::" , stringify ! ( vscan ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _drmModeModeInfo ) ) . vrefresh as *
                const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( _drmModeModeInfo ) ,
                "::" , stringify ! ( vrefresh ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _drmModeModeInfo ) ) . flags as * const _
                as usize } , 28usize , concat ! (
                "Alignment of field: " , stringify ! ( _drmModeModeInfo ) ,
                "::" , stringify ! ( flags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _drmModeModeInfo ) ) . type_ as * const _
                as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( _drmModeModeInfo ) ,
                "::" , stringify ! ( type_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _drmModeModeInfo ) ) . name as * const _
                as usize } , 36usize , concat ! (
                "Alignment of field: " , stringify ! ( _drmModeModeInfo ) ,
                "::" , stringify ! ( name ) ));
}
impl Clone for _drmModeModeInfo {
    fn clone(&self) -> Self { *self }
}
pub type drmModeModeInfo = _drmModeModeInfo;
pub type drmModeModeInfoPtr = *mut _drmModeModeInfo;
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct _drmModeFB {
    pub fb_id: u32,
    pub width: u32,
    pub height: u32,
    pub pitch: u32,
    pub bpp: u32,
    pub depth: u32,
    pub handle: u32,
}
#[test]
fn bindgen_test_layout__drmModeFB() {
    assert_eq!(::std::mem::size_of::<_drmModeFB>() , 28usize , concat ! (
               "Size of: " , stringify ! ( _drmModeFB ) ));
    assert_eq! (::std::mem::align_of::<_drmModeFB>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( _drmModeFB ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _drmModeFB ) ) . fb_id as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _drmModeFB ) , "::" ,
                stringify ! ( fb_id ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _drmModeFB ) ) . width as * const _ as
                usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( _drmModeFB ) , "::" ,
                stringify ! ( width ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _drmModeFB ) ) . height as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( _drmModeFB ) , "::" ,
                stringify ! ( height ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _drmModeFB ) ) . pitch as * const _ as
                usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( _drmModeFB ) , "::" ,
                stringify ! ( pitch ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _drmModeFB ) ) . bpp as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( _drmModeFB ) , "::" ,
                stringify ! ( bpp ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _drmModeFB ) ) . depth as * const _ as
                usize } , 20usize , concat ! (
                "Alignment of field: " , stringify ! ( _drmModeFB ) , "::" ,
                stringify ! ( depth ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _drmModeFB ) ) . handle as * const _ as
                usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( _drmModeFB ) , "::" ,
                stringify ! ( handle ) ));
}
impl Clone for _drmModeFB {
    fn clone(&self) -> Self { *self }
}
pub type drmModeFB = _drmModeFB;
pub type drmModeFBPtr = *mut _drmModeFB;
pub type drmModeClip = drm_clip_rect;
pub type drmModeClipPtr = *mut drm_clip_rect;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _drmModePropertyBlob {
    pub id: u32,
    pub length: u32,
    pub data: *mut libc::c_void,
}
#[test]
fn bindgen_test_layout__drmModePropertyBlob() {
    assert_eq!(::std::mem::size_of::<_drmModePropertyBlob>() , 16usize ,
               concat ! ( "Size of: " , stringify ! ( _drmModePropertyBlob )
               ));
    assert_eq! (::std::mem::align_of::<_drmModePropertyBlob>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( _drmModePropertyBlob ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _drmModePropertyBlob ) ) . id as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _drmModePropertyBlob )
                , "::" , stringify ! ( id ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _drmModePropertyBlob ) ) . length as *
                const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( _drmModePropertyBlob )
                , "::" , stringify ! ( length ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _drmModePropertyBlob ) ) . data as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( _drmModePropertyBlob )
                , "::" , stringify ! ( data ) ));
}
impl Clone for _drmModePropertyBlob {
    fn clone(&self) -> Self { *self }
}
impl Default for _drmModePropertyBlob {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type drmModePropertyBlobRes = _drmModePropertyBlob;
pub type drmModePropertyBlobPtr = *mut _drmModePropertyBlob;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _drmModeProperty {
    pub prop_id: u32,
    pub flags: u32,
    pub name: [libc::c_char; 32usize],
    pub count_values: libc::c_int,
    pub values: *mut u64,
    pub count_enums: libc::c_int,
    pub enums: *mut drm_mode_property_enum,
    pub count_blobs: libc::c_int,
    pub blob_ids: *mut u32,
}
#[test]
fn bindgen_test_layout__drmModeProperty() {
    assert_eq!(::std::mem::size_of::<_drmModeProperty>() , 88usize , concat !
               ( "Size of: " , stringify ! ( _drmModeProperty ) ));
    assert_eq! (::std::mem::align_of::<_drmModeProperty>() , 8usize , concat !
                ( "Alignment of " , stringify ! ( _drmModeProperty ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _drmModeProperty ) ) . prop_id as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _drmModeProperty ) ,
                "::" , stringify ! ( prop_id ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _drmModeProperty ) ) . flags as * const _
                as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( _drmModeProperty ) ,
                "::" , stringify ! ( flags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _drmModeProperty ) ) . name as * const _
                as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( _drmModeProperty ) ,
                "::" , stringify ! ( name ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _drmModeProperty ) ) . count_values as *
                const _ as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( _drmModeProperty ) ,
                "::" , stringify ! ( count_values ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _drmModeProperty ) ) . values as * const
                _ as usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( _drmModeProperty ) ,
                "::" , stringify ! ( values ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _drmModeProperty ) ) . count_enums as *
                const _ as usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( _drmModeProperty ) ,
                "::" , stringify ! ( count_enums ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _drmModeProperty ) ) . enums as * const _
                as usize } , 64usize , concat ! (
                "Alignment of field: " , stringify ! ( _drmModeProperty ) ,
                "::" , stringify ! ( enums ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _drmModeProperty ) ) . count_blobs as *
                const _ as usize } , 72usize , concat ! (
                "Alignment of field: " , stringify ! ( _drmModeProperty ) ,
                "::" , stringify ! ( count_blobs ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _drmModeProperty ) ) . blob_ids as *
                const _ as usize } , 80usize , concat ! (
                "Alignment of field: " , stringify ! ( _drmModeProperty ) ,
                "::" , stringify ! ( blob_ids ) ));
}
impl Clone for _drmModeProperty {
    fn clone(&self) -> Self { *self }
}
impl Default for _drmModeProperty {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type drmModePropertyRes = _drmModeProperty;
pub type drmModePropertyPtr = *mut _drmModeProperty;
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct _drmModeCrtc {
    pub crtc_id: u32,
    pub buffer_id: u32,
    pub x: u32,
    pub y: u32,
    pub width: u32,
    pub height: u32,
    pub mode_valid: libc::c_int,
    pub mode: drmModeModeInfo,
    pub gamma_size: libc::c_int,
}
#[test]
fn bindgen_test_layout__drmModeCrtc() {
    assert_eq!(::std::mem::size_of::<_drmModeCrtc>() , 100usize , concat ! (
               "Size of: " , stringify ! ( _drmModeCrtc ) ));
    assert_eq! (::std::mem::align_of::<_drmModeCrtc>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( _drmModeCrtc ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _drmModeCrtc ) ) . crtc_id as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _drmModeCrtc ) , "::" ,
                stringify ! ( crtc_id ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _drmModeCrtc ) ) . buffer_id as * const _
                as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( _drmModeCrtc ) , "::" ,
                stringify ! ( buffer_id ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _drmModeCrtc ) ) . x as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( _drmModeCrtc ) , "::" ,
                stringify ! ( x ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _drmModeCrtc ) ) . y as * const _ as
                usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( _drmModeCrtc ) , "::" ,
                stringify ! ( y ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _drmModeCrtc ) ) . width as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( _drmModeCrtc ) , "::" ,
                stringify ! ( width ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _drmModeCrtc ) ) . height as * const _ as
                usize } , 20usize , concat ! (
                "Alignment of field: " , stringify ! ( _drmModeCrtc ) , "::" ,
                stringify ! ( height ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _drmModeCrtc ) ) . mode_valid as * const
                _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( _drmModeCrtc ) , "::" ,
                stringify ! ( mode_valid ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _drmModeCrtc ) ) . mode as * const _ as
                usize } , 28usize , concat ! (
                "Alignment of field: " , stringify ! ( _drmModeCrtc ) , "::" ,
                stringify ! ( mode ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _drmModeCrtc ) ) . gamma_size as * const
                _ as usize } , 96usize , concat ! (
                "Alignment of field: " , stringify ! ( _drmModeCrtc ) , "::" ,
                stringify ! ( gamma_size ) ));
}
impl Clone for _drmModeCrtc {
    fn clone(&self) -> Self { *self }
}
pub type drmModeCrtc = _drmModeCrtc;
pub type drmModeCrtcPtr = *mut _drmModeCrtc;
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct _drmModeEncoder {
    pub encoder_id: u32,
    pub encoder_type: u32,
    pub crtc_id: u32,
    pub possible_crtcs: u32,
    pub possible_clones: u32,
}
#[test]
fn bindgen_test_layout__drmModeEncoder() {
    assert_eq!(::std::mem::size_of::<_drmModeEncoder>() , 20usize , concat ! (
               "Size of: " , stringify ! ( _drmModeEncoder ) ));
    assert_eq! (::std::mem::align_of::<_drmModeEncoder>() , 4usize , concat !
                ( "Alignment of " , stringify ! ( _drmModeEncoder ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _drmModeEncoder ) ) . encoder_id as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _drmModeEncoder ) ,
                "::" , stringify ! ( encoder_id ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _drmModeEncoder ) ) . encoder_type as *
                const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( _drmModeEncoder ) ,
                "::" , stringify ! ( encoder_type ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _drmModeEncoder ) ) . crtc_id as * const
                _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( _drmModeEncoder ) ,
                "::" , stringify ! ( crtc_id ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _drmModeEncoder ) ) . possible_crtcs as *
                const _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( _drmModeEncoder ) ,
                "::" , stringify ! ( possible_crtcs ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _drmModeEncoder ) ) . possible_clones as
                * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( _drmModeEncoder ) ,
                "::" , stringify ! ( possible_clones ) ));
}
impl Clone for _drmModeEncoder {
    fn clone(&self) -> Self { *self }
}
pub type drmModeEncoder = _drmModeEncoder;
pub type drmModeEncoderPtr = *mut _drmModeEncoder;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum drmModeConnection {
    DRM_MODE_CONNECTED = 1,
    DRM_MODE_DISCONNECTED = 2,
    DRM_MODE_UNKNOWNCONNECTION = 3,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum drmModeSubPixel {
    DRM_MODE_SUBPIXEL_UNKNOWN = 1,
    DRM_MODE_SUBPIXEL_HORIZONTAL_RGB = 2,
    DRM_MODE_SUBPIXEL_HORIZONTAL_BGR = 3,
    DRM_MODE_SUBPIXEL_VERTICAL_RGB = 4,
    DRM_MODE_SUBPIXEL_VERTICAL_BGR = 5,
    DRM_MODE_SUBPIXEL_NONE = 6,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _drmModeConnector {
    pub connector_id: u32,
    pub encoder_id: u32,
    pub connector_type: u32,
    pub connector_type_id: u32,
    pub connection: drmModeConnection,
    pub mmWidth: u32,
    pub mmHeight: u32,
    pub subpixel: drmModeSubPixel,
    pub count_modes: libc::c_int,
    pub modes: drmModeModeInfoPtr,
    pub count_props: libc::c_int,
    pub props: *mut u32,
    pub prop_values: *mut u64,
    pub count_encoders: libc::c_int,
    pub encoders: *mut u32,
}
#[test]
fn bindgen_test_layout__drmModeConnector() {
    assert_eq!(::std::mem::size_of::<_drmModeConnector>() , 88usize , concat !
               ( "Size of: " , stringify ! ( _drmModeConnector ) ));
    assert_eq! (::std::mem::align_of::<_drmModeConnector>() , 8usize , concat
                ! ( "Alignment of " , stringify ! ( _drmModeConnector ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _drmModeConnector ) ) . connector_id as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _drmModeConnector ) ,
                "::" , stringify ! ( connector_id ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _drmModeConnector ) ) . encoder_id as *
                const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( _drmModeConnector ) ,
                "::" , stringify ! ( encoder_id ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _drmModeConnector ) ) . connector_type as
                * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( _drmModeConnector ) ,
                "::" , stringify ! ( connector_type ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _drmModeConnector ) ) . connector_type_id
                as * const _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( _drmModeConnector ) ,
                "::" , stringify ! ( connector_type_id ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _drmModeConnector ) ) . connection as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( _drmModeConnector ) ,
                "::" , stringify ! ( connection ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _drmModeConnector ) ) . mmWidth as *
                const _ as usize } , 20usize , concat ! (
                "Alignment of field: " , stringify ! ( _drmModeConnector ) ,
                "::" , stringify ! ( mmWidth ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _drmModeConnector ) ) . mmHeight as *
                const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( _drmModeConnector ) ,
                "::" , stringify ! ( mmHeight ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _drmModeConnector ) ) . subpixel as *
                const _ as usize } , 28usize , concat ! (
                "Alignment of field: " , stringify ! ( _drmModeConnector ) ,
                "::" , stringify ! ( subpixel ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _drmModeConnector ) ) . count_modes as *
                const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( _drmModeConnector ) ,
                "::" , stringify ! ( count_modes ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _drmModeConnector ) ) . modes as * const
                _ as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( _drmModeConnector ) ,
                "::" , stringify ! ( modes ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _drmModeConnector ) ) . count_props as *
                const _ as usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( _drmModeConnector ) ,
                "::" , stringify ! ( count_props ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _drmModeConnector ) ) . props as * const
                _ as usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( _drmModeConnector ) ,
                "::" , stringify ! ( props ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _drmModeConnector ) ) . prop_values as *
                const _ as usize } , 64usize , concat ! (
                "Alignment of field: " , stringify ! ( _drmModeConnector ) ,
                "::" , stringify ! ( prop_values ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _drmModeConnector ) ) . count_encoders as
                * const _ as usize } , 72usize , concat ! (
                "Alignment of field: " , stringify ! ( _drmModeConnector ) ,
                "::" , stringify ! ( count_encoders ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _drmModeConnector ) ) . encoders as *
                const _ as usize } , 80usize , concat ! (
                "Alignment of field: " , stringify ! ( _drmModeConnector ) ,
                "::" , stringify ! ( encoders ) ));
}
impl Clone for _drmModeConnector {
    fn clone(&self) -> Self { *self }
}
impl Default for _drmModeConnector {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type drmModeConnector = _drmModeConnector;
pub type drmModeConnectorPtr = *mut _drmModeConnector;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _drmModeObjectProperties {
    pub count_props: u32,
    pub props: *mut u32,
    pub prop_values: *mut u64,
}
#[test]
fn bindgen_test_layout__drmModeObjectProperties() {
    assert_eq!(::std::mem::size_of::<_drmModeObjectProperties>() , 24usize ,
               concat ! (
               "Size of: " , stringify ! ( _drmModeObjectProperties ) ));
    assert_eq! (::std::mem::align_of::<_drmModeObjectProperties>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( _drmModeObjectProperties ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _drmModeObjectProperties ) ) .
                count_props as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                _drmModeObjectProperties ) , "::" , stringify ! ( count_props
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _drmModeObjectProperties ) ) . props as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                _drmModeObjectProperties ) , "::" , stringify ! ( props ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _drmModeObjectProperties ) ) .
                prop_values as * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! (
                _drmModeObjectProperties ) , "::" , stringify ! ( prop_values
                ) ));
}
impl Clone for _drmModeObjectProperties {
    fn clone(&self) -> Self { *self }
}
impl Default for _drmModeObjectProperties {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type drmModeObjectProperties = _drmModeObjectProperties;
pub type drmModeObjectPropertiesPtr = *mut _drmModeObjectProperties;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _drmModePlane {
    pub count_formats: u32,
    pub formats: *mut u32,
    pub plane_id: u32,
    pub crtc_id: u32,
    pub fb_id: u32,
    pub crtc_x: u32,
    pub crtc_y: u32,
    pub x: u32,
    pub y: u32,
    pub possible_crtcs: u32,
    pub gamma_size: u32,
}
#[test]
fn bindgen_test_layout__drmModePlane() {
    assert_eq!(::std::mem::size_of::<_drmModePlane>() , 56usize , concat ! (
               "Size of: " , stringify ! ( _drmModePlane ) ));
    assert_eq! (::std::mem::align_of::<_drmModePlane>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( _drmModePlane ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _drmModePlane ) ) . count_formats as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _drmModePlane ) , "::"
                , stringify ! ( count_formats ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _drmModePlane ) ) . formats as * const _
                as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( _drmModePlane ) , "::"
                , stringify ! ( formats ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _drmModePlane ) ) . plane_id as * const _
                as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( _drmModePlane ) , "::"
                , stringify ! ( plane_id ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _drmModePlane ) ) . crtc_id as * const _
                as usize } , 20usize , concat ! (
                "Alignment of field: " , stringify ! ( _drmModePlane ) , "::"
                , stringify ! ( crtc_id ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _drmModePlane ) ) . fb_id as * const _ as
                usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( _drmModePlane ) , "::"
                , stringify ! ( fb_id ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _drmModePlane ) ) . crtc_x as * const _
                as usize } , 28usize , concat ! (
                "Alignment of field: " , stringify ! ( _drmModePlane ) , "::"
                , stringify ! ( crtc_x ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _drmModePlane ) ) . crtc_y as * const _
                as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( _drmModePlane ) , "::"
                , stringify ! ( crtc_y ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _drmModePlane ) ) . x as * const _ as
                usize } , 36usize , concat ! (
                "Alignment of field: " , stringify ! ( _drmModePlane ) , "::"
                , stringify ! ( x ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _drmModePlane ) ) . y as * const _ as
                usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( _drmModePlane ) , "::"
                , stringify ! ( y ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _drmModePlane ) ) . possible_crtcs as *
                const _ as usize } , 44usize , concat ! (
                "Alignment of field: " , stringify ! ( _drmModePlane ) , "::"
                , stringify ! ( possible_crtcs ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _drmModePlane ) ) . gamma_size as * const
                _ as usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( _drmModePlane ) , "::"
                , stringify ! ( gamma_size ) ));
}
impl Clone for _drmModePlane {
    fn clone(&self) -> Self { *self }
}
impl Default for _drmModePlane {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type drmModePlane = _drmModePlane;
pub type drmModePlanePtr = *mut _drmModePlane;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _drmModePlaneRes {
    pub count_planes: u32,
    pub planes: *mut u32,
}
#[test]
fn bindgen_test_layout__drmModePlaneRes() {
    assert_eq!(::std::mem::size_of::<_drmModePlaneRes>() , 16usize , concat !
               ( "Size of: " , stringify ! ( _drmModePlaneRes ) ));
    assert_eq! (::std::mem::align_of::<_drmModePlaneRes>() , 8usize , concat !
                ( "Alignment of " , stringify ! ( _drmModePlaneRes ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _drmModePlaneRes ) ) . count_planes as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _drmModePlaneRes ) ,
                "::" , stringify ! ( count_planes ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _drmModePlaneRes ) ) . planes as * const
                _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( _drmModePlaneRes ) ,
                "::" , stringify ! ( planes ) ));
}
impl Clone for _drmModePlaneRes {
    fn clone(&self) -> Self { *self }
}
impl Default for _drmModePlaneRes {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type drmModePlaneRes = _drmModePlaneRes;
pub type drmModePlaneResPtr = *mut _drmModePlaneRes;
extern "C" {
    pub fn drmModeFreeModeInfo(ptr: drmModeModeInfoPtr);
}
extern "C" {
    pub fn drmModeFreeResources(ptr: drmModeResPtr);
}
extern "C" {
    pub fn drmModeFreeFB(ptr: drmModeFBPtr);
}
extern "C" {
    pub fn drmModeFreeCrtc(ptr: drmModeCrtcPtr);
}
extern "C" {
    pub fn drmModeFreeConnector(ptr: drmModeConnectorPtr);
}
extern "C" {
    pub fn drmModeFreeEncoder(ptr: drmModeEncoderPtr);
}
extern "C" {
    pub fn drmModeFreePlane(ptr: drmModePlanePtr);
}
extern "C" {
    pub fn drmModeFreePlaneResources(ptr: drmModePlaneResPtr);
}
extern "C" {
    pub fn drmModeGetResources(fd: libc::c_int) -> drmModeResPtr;
}
extern "C" {
    pub fn drmModeGetFB(fd: libc::c_int, bufferId: u32) -> drmModeFBPtr;
}
extern "C" {
    pub fn drmModeAddFB(fd: libc::c_int, width: u32, height: u32, depth: u8,
                        bpp: u8, pitch: u32, bo_handle: u32, buf_id: *mut u32)
     -> libc::c_int;
}
extern "C" {
    pub fn drmModeAddFB2(fd: libc::c_int, width: u32, height: u32,
                         pixel_format: u32, bo_handles: *mut u32,
                         pitches: *mut u32, offsets: *mut u32,
                         buf_id: *mut u32, flags: u32) -> libc::c_int;
}
extern "C" {
    pub fn drmModeAddFB2WithModifiers(fd: libc::c_int, width: u32,
                                      height: u32, pixel_format: u32,
                                      bo_handles: *mut u32, pitches: *mut u32,
                                      offsets: *mut u32, modifier: *mut u64,
                                      buf_id: *mut u32, flags: u32)
     -> libc::c_int;
}
extern "C" {
    pub fn drmModeRmFB(fd: libc::c_int, bufferId: u32) -> libc::c_int;
}
extern "C" {
    pub fn drmModeDirtyFB(fd: libc::c_int, bufferId: u32,
                          clips: drmModeClipPtr, num_clips: u32)
     -> libc::c_int;
}
extern "C" {
    pub fn drmModeGetCrtc(fd: libc::c_int, crtcId: u32) -> drmModeCrtcPtr;
}
extern "C" {
    pub fn drmModeSetCrtc(fd: libc::c_int, crtcId: u32, bufferId: u32, x: u32,
                          y: u32, connectors: *mut u32, count: libc::c_int,
                          mode: drmModeModeInfoPtr) -> libc::c_int;
}
extern "C" {
    pub fn drmModeSetCursor(fd: libc::c_int, crtcId: u32, bo_handle: u32,
                            width: u32, height: u32) -> libc::c_int;
}
extern "C" {
    pub fn drmModeSetCursor2(fd: libc::c_int, crtcId: u32, bo_handle: u32,
                             width: u32, height: u32, hot_x: i32, hot_y: i32)
     -> libc::c_int;
}
extern "C" {
    pub fn drmModeMoveCursor(fd: libc::c_int, crtcId: u32, x: libc::c_int,
                             y: libc::c_int) -> libc::c_int;
}
extern "C" {
    pub fn drmModeGetEncoder(fd: libc::c_int, encoder_id: u32)
     -> drmModeEncoderPtr;
}
extern "C" {
    pub fn drmModeGetConnector(fd: libc::c_int, connectorId: u32)
     -> drmModeConnectorPtr;
}
extern "C" {
    pub fn drmModeGetConnectorCurrent(fd: libc::c_int, connector_id: u32)
     -> drmModeConnectorPtr;
}
extern "C" {
    pub fn drmModeAttachMode(fd: libc::c_int, connectorId: u32,
                             mode_info: drmModeModeInfoPtr) -> libc::c_int;
}
extern "C" {
    pub fn drmModeDetachMode(fd: libc::c_int, connectorId: u32,
                             mode_info: drmModeModeInfoPtr) -> libc::c_int;
}
extern "C" {
    pub fn drmModeGetProperty(fd: libc::c_int, propertyId: u32)
     -> drmModePropertyPtr;
}
extern "C" {
    pub fn drmModeFreeProperty(ptr: drmModePropertyPtr);
}
extern "C" {
    pub fn drmModeGetPropertyBlob(fd: libc::c_int, blob_id: u32)
     -> drmModePropertyBlobPtr;
}
extern "C" {
    pub fn drmModeFreePropertyBlob(ptr: drmModePropertyBlobPtr);
}
extern "C" {
    pub fn drmModeConnectorSetProperty(fd: libc::c_int, connector_id: u32,
                                       property_id: u32, value: u64)
     -> libc::c_int;
}
extern "C" {
    pub fn drmCheckModesettingSupported(busid: *const libc::c_char)
     -> libc::c_int;
}
extern "C" {
    pub fn drmModeCrtcSetGamma(fd: libc::c_int, crtc_id: u32, size: u32,
                               red: *mut u16, green: *mut u16, blue: *mut u16)
     -> libc::c_int;
}
extern "C" {
    pub fn drmModeCrtcGetGamma(fd: libc::c_int, crtc_id: u32, size: u32,
                               red: *mut u16, green: *mut u16, blue: *mut u16)
     -> libc::c_int;
}
extern "C" {
    pub fn drmModePageFlip(fd: libc::c_int, crtc_id: u32, fb_id: u32,
                           flags: u32, user_data: *mut libc::c_void)
     -> libc::c_int;
}
extern "C" {
    pub fn drmModePageFlipTarget(fd: libc::c_int, crtc_id: u32, fb_id: u32,
                                 flags: u32, user_data: *mut libc::c_void,
                                 target_vblank: u32) -> libc::c_int;
}
extern "C" {
    pub fn drmModeGetPlaneResources(fd: libc::c_int) -> drmModePlaneResPtr;
}
extern "C" {
    pub fn drmModeGetPlane(fd: libc::c_int, plane_id: u32) -> drmModePlanePtr;
}
extern "C" {
    pub fn drmModeSetPlane(fd: libc::c_int, plane_id: u32, crtc_id: u32,
                           fb_id: u32, flags: u32, crtc_x: i32, crtc_y: i32,
                           crtc_w: u32, crtc_h: u32, src_x: u32, src_y: u32,
                           src_w: u32, src_h: u32) -> libc::c_int;
}
extern "C" {
    pub fn drmModeObjectGetProperties(fd: libc::c_int, object_id: u32,
                                      object_type: u32)
     -> drmModeObjectPropertiesPtr;
}
extern "C" {
    pub fn drmModeFreeObjectProperties(ptr: drmModeObjectPropertiesPtr);
}
extern "C" {
    pub fn drmModeObjectSetProperty(fd: libc::c_int, object_id: u32,
                                    object_type: u32, property_id: u32,
                                    value: u64) -> libc::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _drmModeAtomicReq([u8; 0]);
pub type drmModeAtomicReq = _drmModeAtomicReq;
pub type drmModeAtomicReqPtr = *mut _drmModeAtomicReq;
extern "C" {
    pub fn drmModeAtomicAlloc() -> drmModeAtomicReqPtr;
}
extern "C" {
    pub fn drmModeAtomicDuplicate(req: drmModeAtomicReqPtr)
     -> drmModeAtomicReqPtr;
}
extern "C" {
    pub fn drmModeAtomicMerge(base: drmModeAtomicReqPtr,
                              augment: drmModeAtomicReqPtr) -> libc::c_int;
}
extern "C" {
    pub fn drmModeAtomicFree(req: drmModeAtomicReqPtr);
}
extern "C" {
    pub fn drmModeAtomicGetCursor(req: drmModeAtomicReqPtr) -> libc::c_int;
}
extern "C" {
    pub fn drmModeAtomicSetCursor(req: drmModeAtomicReqPtr,
                                  cursor: libc::c_int);
}
extern "C" {
    pub fn drmModeAtomicAddProperty(req: drmModeAtomicReqPtr, object_id: u32,
                                    property_id: u32, value: u64)
     -> libc::c_int;
}
extern "C" {
    pub fn drmModeAtomicCommit(fd: libc::c_int, req: drmModeAtomicReqPtr,
                               flags: u32, user_data: *mut libc::c_void)
     -> libc::c_int;
}
extern "C" {
    pub fn drmModeCreatePropertyBlob(fd: libc::c_int,
                                     data: *const libc::c_void, size: usize,
                                     id: *mut u32) -> libc::c_int;
}
extern "C" {
    pub fn drmModeDestroyPropertyBlob(fd: libc::c_int, id: u32)
     -> libc::c_int;
}
pub const MACRO_DRM_MODE_PROP_EXTENDED_TYPE: libc::c_uint = 65472;
pub const MACRO_DRM_MODE_PROP_OBJECT: libc::c_uint = 64;
pub const MACRO_DRM_MODE_PROP_SIGNED_RANGE: libc::c_uint = 128;
pub const MACRO_DRM_MODE_ATOMIC_ALLOW_MODESET: libc::c_uint = 1024;
pub const MACRO_DRM_IOCTL_VERSION: libc::c_long = -1069521920;
pub const MACRO_DRM_IOCTL_GET_UNIQUE: libc::c_long = -1072667647;
pub const MACRO_DRM_IOCTL_GET_MAGIC: libc::c_long = -2147195902;
pub const MACRO_DRM_IOCTL_IRQ_BUSID: libc::c_long = -1072667645;
pub const MACRO_DRM_IOCTL_GET_MAP: libc::c_long = -1071094780;
pub const MACRO_DRM_IOCTL_GET_CLIENT: libc::c_long = -1071094779;
pub const MACRO_DRM_IOCTL_GET_STATS: libc::c_long = -2131205114;
pub const MACRO_DRM_IOCTL_SET_VERSION: libc::c_long = -1072667641;
pub const MACRO_DRM_IOCTL_MODESET_CTL: libc::c_long = 1074291720;
pub const MACRO_DRM_IOCTL_GEM_CLOSE: libc::c_long = 1074291721;
pub const MACRO_DRM_IOCTL_GEM_FLINK: libc::c_long = -1073191926;
pub const MACRO_DRM_IOCTL_GEM_OPEN: libc::c_long = -1072667637;
pub const MACRO_DRM_IOCTL_GET_CAP: libc::c_long = -1072667636;
pub const MACRO_DRM_IOCTL_SET_CLIENT_CAP: libc::c_long = 1074816013;
pub const MACRO_DRM_IOCTL_SET_UNIQUE: libc::c_long = 1074816016;
pub const MACRO_DRM_IOCTL_AUTH_MAGIC: libc::c_long = 1074029585;
pub const MACRO_DRM_IOCTL_BLOCK: libc::c_long = -1073454062;
pub const MACRO_DRM_IOCTL_UNBLOCK: libc::c_long = -1073454061;
pub const MACRO_DRM_IOCTL_CONTROL: libc::c_long = 1074291732;
pub const MACRO_DRM_IOCTL_ADD_MAP: libc::c_long = -1071094763;
pub const MACRO_DRM_IOCTL_ADD_BUFS: libc::c_long = -1071619050;
pub const MACRO_DRM_IOCTL_MARK_BUFS: libc::c_long = 1075864599;
pub const MACRO_DRM_IOCTL_INFO_BUFS: libc::c_long = -1072667624;
pub const MACRO_DRM_IOCTL_MAP_BUFS: libc::c_long = -1072143335;
pub const MACRO_DRM_IOCTL_FREE_BUFS: libc::c_long = 1074816026;
pub const MACRO_DRM_IOCTL_RM_MAP: libc::c_long = 1076388891;
pub const MACRO_DRM_IOCTL_SET_SAREA_CTX: libc::c_long = 1074816028;
pub const MACRO_DRM_IOCTL_GET_SAREA_CTX: libc::c_long = -1072667619;
pub const MACRO_DRM_IOCTL_SET_MASTER: libc::c_long = 25630;
pub const MACRO_DRM_IOCTL_DROP_MASTER: libc::c_long = 25631;
pub const MACRO_DRM_IOCTL_ADD_CTX: libc::c_long = -1073191904;
pub const MACRO_DRM_IOCTL_RM_CTX: libc::c_long = -1073191903;
pub const MACRO_DRM_IOCTL_MOD_CTX: libc::c_long = 1074291746;
pub const MACRO_DRM_IOCTL_GET_CTX: libc::c_long = -1073191901;
pub const MACRO_DRM_IOCTL_SWITCH_CTX: libc::c_long = 1074291748;
pub const MACRO_DRM_IOCTL_NEW_CTX: libc::c_long = 1074291749;
pub const MACRO_DRM_IOCTL_RES_CTX: libc::c_long = -1072667610;
pub const MACRO_DRM_IOCTL_ADD_DRAW: libc::c_long = -1073454041;
pub const MACRO_DRM_IOCTL_RM_DRAW: libc::c_long = -1073454040;
pub const MACRO_DRM_IOCTL_DMA: libc::c_long = -1069521879;
pub const MACRO_DRM_IOCTL_LOCK: libc::c_long = 1074291754;
pub const MACRO_DRM_IOCTL_UNLOCK: libc::c_long = 1074291755;
pub const MACRO_DRM_IOCTL_FINISH: libc::c_long = 1074291756;
pub const MACRO_DRM_IOCTL_PRIME_HANDLE_TO_FD: libc::c_long = -1072929747;
pub const MACRO_DRM_IOCTL_PRIME_FD_TO_HANDLE: libc::c_long = -1072929746;
pub const MACRO_DRM_IOCTL_AGP_ACQUIRE: libc::c_long = 25648;
pub const MACRO_DRM_IOCTL_AGP_RELEASE: libc::c_long = 25649;
pub const MACRO_DRM_IOCTL_AGP_ENABLE: libc::c_long = 1074291762;
pub const MACRO_DRM_IOCTL_AGP_INFO: libc::c_long = -2143787981;
pub const MACRO_DRM_IOCTL_AGP_ALLOC: libc::c_long = -1071619020;
pub const MACRO_DRM_IOCTL_AGP_FREE: libc::c_long = 1075864629;
pub const MACRO_DRM_IOCTL_AGP_BIND: libc::c_long = 1074816054;
pub const MACRO_DRM_IOCTL_AGP_UNBIND: libc::c_long = 1074816055;
pub const MACRO_DRM_IOCTL_SG_ALLOC: libc::c_long = -1072667592;
pub const MACRO_DRM_IOCTL_SG_FREE: libc::c_long = 1074816057;
pub const MACRO_DRM_IOCTL_WAIT_VBLANK: libc::c_long = -1072143302;
pub const MACRO_DRM_IOCTL_UPDATE_DRAW: libc::c_long = 1075340351;
pub const MACRO_DRM_IOCTL_MODE_GETRESOURCES: libc::c_long = -1069521760;
pub const MACRO_DRM_IOCTL_MODE_GETCRTC: libc::c_long = -1066900319;
pub const MACRO_DRM_IOCTL_MODE_SETCRTC: libc::c_long = -1066900318;
pub const MACRO_DRM_IOCTL_MODE_CURSOR: libc::c_long = -1071881053;
pub const MACRO_DRM_IOCTL_MODE_GETGAMMA: libc::c_long = -1071618908;
pub const MACRO_DRM_IOCTL_MODE_SETGAMMA: libc::c_long = -1071618907;
pub const MACRO_DRM_IOCTL_MODE_GETENCODER: libc::c_long = -1072405338;
pub const MACRO_DRM_IOCTL_MODE_GETCONNECTOR: libc::c_long = -1068473177;
pub const MACRO_DRM_IOCTL_MODE_ATTACHMODE: libc::c_long = -1068997464;
pub const MACRO_DRM_IOCTL_MODE_DETACHMODE: libc::c_long = -1068997463;
pub const MACRO_DRM_IOCTL_MODE_GETPROPERTY: libc::c_long = -1069521750;
pub const MACRO_DRM_IOCTL_MODE_SETPROPERTY: libc::c_long = -1072667477;
pub const MACRO_DRM_IOCTL_MODE_GETPROPBLOB: libc::c_long = -1072667476;
pub const MACRO_DRM_IOCTL_MODE_GETFB: libc::c_long = -1071881043;
pub const MACRO_DRM_IOCTL_MODE_ADDFB: libc::c_long = -1071881042;
pub const MACRO_DRM_IOCTL_MODE_RMFB: libc::c_long = -1073453905;
pub const MACRO_DRM_IOCTL_MODE_PAGE_FLIP: libc::c_long = -1072143184;
pub const MACRO_DRM_IOCTL_MODE_DIRTYFB: libc::c_long = -1072143183;
pub const MACRO_DRM_IOCTL_MODE_CREATE_DUMB: libc::c_long = -1071618894;
pub const MACRO_DRM_IOCTL_MODE_MAP_DUMB: libc::c_long = -1072667469;
pub const MACRO_DRM_IOCTL_MODE_DESTROY_DUMB: libc::c_long = -1073453900;
pub const MACRO_DRM_IOCTL_MODE_GETPLANERESOURCES: libc::c_long = -1072667467;
pub const MACRO_DRM_IOCTL_MODE_GETPLANE: libc::c_long = -1071618890;
pub const MACRO_DRM_IOCTL_MODE_SETPLANE: libc::c_long = -1070570313;
pub const MACRO_DRM_IOCTL_MODE_ADDFB2: libc::c_long = -1066900296;
pub const MACRO_DRM_IOCTL_MODE_OBJ_GETPROPERTIES: libc::c_long = -1071618887;
pub const MACRO_DRM_IOCTL_MODE_OBJ_SETPROPERTY: libc::c_long = -1072143174;
pub const MACRO_DRM_IOCTL_MODE_CURSOR2: libc::c_long = -1071356741;
pub const MACRO_DRM_IOCTL_MODE_ATOMIC: libc::c_long = -1070046020;
pub const MACRO_DRM_IOCTL_MODE_CREATEPROPBLOB: libc::c_long = -1072667459;
pub const MACRO_DRM_IOCTL_MODE_DESTROYPROPBLOB: libc::c_long = -1073453890;
